<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Hand Tracking with GLB Models</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
            position: relative;
        }
        
        #videoContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #canvas3d {
            width: 100%;
            height: 100%;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 10;
            max-width: 350px;
        }
        
        #status {
            color: #00ff00;
            margin-top: 10px;
        }
        
        .landmark-info {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
        
        .debug-info {
            margin-top: 10px;
            font-size: 11px;
            color: #aaa;
            font-family: monospace;
        }
        
        .rotation-controls {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        
        .rotation-controls h4 {
            margin: 0 0 10px 0;
            color: #00ff00;
            font-size: 12px;
        }
        
        .rotation-control {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 11px;
        }
        
        .rotation-control label {
            width: 80px;
            color: #ccc;
        }
        
        .rotation-control input[type="range"] {
            width: 150px;
            margin: 0 10px;
        }
        
        .rotation-control span {
            width: 60px;
            color: #00ff00;
            font-family: monospace;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #00ff00;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas3d"></canvas>
        <div id="videoContainer">
            <video id="video" playsinline></video>
        </div>
        <div id="info">
            <h3>MediaPipe Hand Tracking</h3>
            <div id="status">초기화 중...</div>
            <div class="landmark-info">
                손 감지: <span id="handDetected">-</span><br>
                손 방향: <span id="handedness">-</span><br>
                FPS: <span id="fps">0</span>
            </div>
            <div class="debug-info">
                손목 위치: <span id="wristPos">-</span><br>
                모델 상태: <span id="modelStatus">모델 로딩 중...</span>
            </div>
            <div class="toggle-switch">
                <label>랜드마크 표시:</label>
                <label class="switch">
                    <input type="checkbox" id="showLandmarks" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button id="saveSettings" style="padding: 8px 16px; background: #00ff00; color: #000; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">설정 저장</button>
                <button id="resetSettings" style="padding: 8px 16px; background: #ff6666; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">기본값 복원</button>
            </div>
            <div class="rotation-controls">
                <h4>오른손 모델 조정</h4>
                <div class="rotation-control">
                    <label>X축 회전:</label>
                    <input type="range" id="leftRotationX" min="-180" max="180" value="0" step="1">
                    <span id="leftRotationXValue">0°</span>
                </div>
                <div class="rotation-control">
                    <label>Y축 회전:</label>
                    <input type="range" id="leftRotationY" min="-180" max="180" value="78" step="1">
                    <span id="leftRotationYValue">78°</span>
                </div>
                <div class="rotation-control">
                    <label>Z축 회전:</label>
                    <input type="range" id="leftRotationZ" min="-180" max="180" value="0" step="1">
                    <span id="leftRotationZValue">0°</span>
                </div>
                <div class="rotation-control">
                    <label>스케일:</label>
                    <input type="range" id="leftModelScale" min="1" max="20" value="8" step="0.5">
                    <span id="leftModelScaleValue">8.0</span>
                </div>
            </div>
            <div class="rotation-controls">
                <h4>왼손 모델 조정</h4>
                <div class="rotation-control">
                    <label>X축 회전:</label>
                    <input type="range" id="rightRotationX" min="-180" max="180" value="-180" step="1">
                    <span id="rightRotationXValue">-180°</span>
                </div>
                <div class="rotation-control">
                    <label>Y축 회전:</label>
                    <input type="range" id="rightRotationY" min="-180" max="180" value="-78" step="1">
                    <span id="rightRotationYValue">-78°</span>
                </div>
                <div class="rotation-control">
                    <label>Z축 회전:</label>
                    <input type="range" id="rightRotationZ" min="-180" max="180" value="0" step="1">
                    <span id="rightRotationZValue">0°</span>
                </div>
                <div class="rotation-control">
                    <label>스케일:</label>
                    <input type="range" id="rightModelScale" min="1" max="20" value="8" step="0.5">
                    <span id="rightModelScaleValue">8.0</span>
                </div>
            </div>
        </div>
        <div class="loading" id="loading">GLB 모델 로딩 중...</div>
    </div>

    <!-- MediaPipe CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Three.js 설정
        let scene, camera, renderer;
        let leftHandModel = null;
        let rightHandModel = null;
        let currentHandModel = null;
        let leftHandJoints = {};
        let rightHandJoints = {};
        let leftHandConnections = [];
        let rightHandConnections = [];
        let showLandmarks = true;
        let modelsLoaded = false;
        
        // 오른손 회전 조정값
        let leftHandRotationX = 0;
        let leftHandRotationY = 73;
        let leftHandRotationZ = 0;
        let leftHandScaleFactor = 11;
        
        // 왼손 회전 조정값
        let rightHandRotationX = -180;
        let rightHandRotationY = -73;
        let rightHandRotationZ = 0;
        let rightHandScaleFactor = 11;
        
        // GLB 파일 경로 설정
        const MODEL_PATH = './Models/';
        const LEFT_HAND_MODEL = MODEL_PATH + 'LeftHand.glb';
        const RIGHT_HAND_MODEL = MODEL_PATH + 'RightHand.glb';
        
        // 설정값 저장/불러오기 함수들
        function saveSettings() {
            const settings = {
                leftHandRotationX,
                leftHandRotationY,
                leftHandRotationZ,
                leftHandScaleFactor,
                rightHandRotationX,
                rightHandRotationY,
                rightHandRotationZ,
                rightHandScaleFactor,
                showLandmarks
            };
            localStorage.setItem('handTrackingSettings', JSON.stringify(settings));
            console.log('설정값이 저장되었습니다.');
        }
        
        function loadSettings() {
            const savedSettings = localStorage.getItem('handTrackingSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    
                    // 왼손(오른손 모델) 설정 적용
                    leftHandRotationX = settings.leftHandRotationX || 0;
                    leftHandRotationY = settings.leftHandRotationY || 73;
                    leftHandRotationZ = settings.leftHandRotationZ || 0;
                    leftHandScaleFactor = settings.leftHandScaleFactor || 11;
                    
                    // 오른손(왼손 모델) 설정 적용
                    rightHandRotationX = settings.rightHandRotationX || -180;
                    rightHandRotationY = settings.rightHandRotationY || -73;
                    rightHandRotationZ = settings.rightHandRotationZ || 0;
                    rightHandScaleFactor = settings.rightHandScaleFactor || 11;
                    
                    // 랜드마크 표시 설정
                    showLandmarks = settings.showLandmarks !== undefined ? settings.showLandmarks : true;
                    
                    // UI 업데이트
                    updateSliderValues();
                    
                    console.log('설정값이 불러와졌습니다.');
                } catch (error) {
                    console.error('설정값 불러오기 실패:', error);
                }
            }
        }
        
        function updateSliderValues() {
            // 왼손(오른손 모델) 슬라이더 값 업데이트
            document.getElementById('leftRotationX').value = leftHandRotationX;
            document.getElementById('leftRotationXValue').textContent = leftHandRotationX + '°';
            document.getElementById('leftRotationY').value = leftHandRotationY;
            document.getElementById('leftRotationYValue').textContent = leftHandRotationY + '°';
            document.getElementById('leftRotationZ').value = leftHandRotationZ;
            document.getElementById('leftRotationZValue').textContent = leftHandRotationZ + '°';
            document.getElementById('leftModelScale').value = leftHandScaleFactor;
            document.getElementById('leftModelScaleValue').textContent = leftHandScaleFactor.toFixed(1);
            
            // 오른손(왼손 모델) 슬라이더 값 업데이트
            document.getElementById('rightRotationX').value = rightHandRotationX;
            document.getElementById('rightRotationXValue').textContent = rightHandRotationX + '°';
            document.getElementById('rightRotationY').value = rightHandRotationY;
            document.getElementById('rightRotationYValue').textContent = rightHandRotationY + '°';
            document.getElementById('rightRotationZ').value = rightHandRotationZ;
            document.getElementById('rightRotationZValue').textContent = rightHandRotationZ + '°';
            document.getElementById('rightModelScale').value = rightHandScaleFactor;
            document.getElementById('rightModelScaleValue').textContent = rightHandScaleFactor.toFixed(1);
            
            // 랜드마크 체크박스 업데이트
            document.getElementById('showLandmarks').checked = showLandmarks;
        }
        
        // MediaPipe 랜드마크 인덱스
        const LANDMARK_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],         // 엄지
            [0, 5], [5, 6], [6, 7], [7, 8],         // 검지
            [0, 9], [9, 10], [10, 11], [11, 12],    // 중지
            [0, 13], [13, 14], [14, 15], [15, 16],  // 약지
            [0, 17], [17, 18], [18, 19], [19, 20],  // 새끼
            [5, 9], [9, 13], [13, 17]               // 손바닥
        ];
        
        // Three.js 초기화
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 0, 0.5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas3d'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // 랜드마크 시각화 생성
            createLandmarkVisualization();
            
            // GLB 모델 자동 로드
            loadModels();
            
            animate();
        }
        
        // 랜드마크 시각화 생성
        function createLandmarkVisualization() {
            // 왼손 랜드마크 구체 생성
            const leftSphereGeometry = new THREE.SphereGeometry(0.008, 16, 16);
            const leftSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.8
            });
            
            for (let i = 0; i < 21; i++) {
                const sphere = new THREE.Mesh(leftSphereGeometry, leftSphereMaterial);
                sphere.name = `left_landmark_${i}`;
                sphere.visible = false;
                scene.add(sphere);
                leftHandJoints[i] = sphere;
            }
            
            // 오른손 랜드마크 구체 생성
            const rightSphereGeometry = new THREE.SphereGeometry(0.008, 16, 16);
            const rightSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            
            for (let i = 0; i < 21; i++) {
                const sphere = new THREE.Mesh(rightSphereGeometry, rightSphereMaterial);
                sphere.name = `right_landmark_${i}`;
                sphere.visible = false;
                scene.add(sphere);
                rightHandJoints[i] = sphere;
            }
            
            // 왼손 연결선 생성
            const leftLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                linewidth: 3,
                transparent: true,
                opacity: 0.9
            });
            
            LANDMARK_CONNECTIONS.forEach(([start, end]) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const line = new THREE.Line(geometry, leftLineMaterial);
                line.name = `left_connection_${start}_${end}`;
                line.visible = false;
                scene.add(line);
                leftHandConnections.push({ line, start, end });
            });
            
            // 오른손 연결선 생성
            const rightLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff0000,
                linewidth: 3,
                transparent: true,
                opacity: 0.9
            });
            
            LANDMARK_CONNECTIONS.forEach(([start, end]) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const line = new THREE.Line(geometry, rightLineMaterial);
                line.name = `right_connection_${start}_${end}`;
                line.visible = false;
                scene.add(line);
                rightHandConnections.push({ line, start, end });
            });
        }
        
        // GLB 모델 자동 로드
        async function loadModels() {
            const loader = new THREE.GLTFLoader();
            
            try {
                // 왼손 모델 로드
                const leftGltf = await new Promise((resolve, reject) => {
                    loader.load(LEFT_HAND_MODEL, resolve, undefined, reject);
                });
                
                leftHandModel = leftGltf.scene;
                setupHandModel(leftHandModel, 'left');
                
                // 오른손 모델 로드
                const rightGltf = await new Promise((resolve, reject) => {
                    loader.load(RIGHT_HAND_MODEL, resolve, undefined, reject);
                });
                
                rightHandModel = rightGltf.scene;
                setupHandModel(rightHandModel, 'right');
                
                modelsLoaded = true;
                document.getElementById('modelStatus').textContent = '양손 모델 로드 완료';
                document.getElementById('loading').style.display = 'none';
                console.log('GLB 모델 로드 완료');
                
            } catch (error) {
                console.error('GLB 모델 로드 실패:', error);
                document.getElementById('modelStatus').textContent = '모델 로드 실패: ' + error.message;
                document.getElementById('loading').textContent = '모델 로드 실패';
                modelsLoaded = false;
            }
        }
        
        // 손 모델 설정
        function setupHandModel(model, handType) {
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.material.side = THREE.DoubleSide;
                }
            });
            
            // 모델의 bone 구조 분석 (디버그용) - 더 자세한 정보
            console.log(`\n=== ${handType} 손 모델의 Bone 구조 분석 ===`);
            const bones = [];
            model.traverse((child) => {
                if (child.isBone) {
                    bones.push({
                        name: child.name,
                        position: child.position.clone(),
                        parent: child.parent ? child.parent.name : 'none'
                    });
                    console.log(`Bone: "${child.name}"
                        - Type: ${child.type}
                        - Position: (${child.position.x.toFixed(3)}, ${child.position.y.toFixed(3)}, ${child.position.z.toFixed(3)})
                        - Parent: ${child.parent ? child.parent.name : 'none'}
                        - Children: ${child.children.length}`);
                }
            });
            
            console.log(`\n총 ${bones.length}개의 bone 발견:`);
            bones.forEach((bone, index) => {
                console.log(`${index + 1}. ${bone.name} (parent: ${bone.parent})`);
            });
            
            // 손가락별 bone 그룹 분석
            const fingerGroups = {
                thumb: bones.filter(b => /thumb/i.test(b.name)),
                index: bones.filter(b => /index/i.test(b.name)),
                middle: bones.filter(b => /middle/i.test(b.name)),
                ring: bones.filter(b => /ring/i.test(b.name)),
                pinky: bones.filter(b => /(pinky|little)/i.test(b.name)),
                other: bones.filter(b => !/thumb|index|middle|ring|pinky|little/i.test(b.name))
            };
            
            console.log(`\n손가락별 bone 분류:`);
            Object.entries(fingerGroups).forEach(([finger, fingerBones]) => {
                if (fingerBones.length > 0) {
                    console.log(`${finger}: ${fingerBones.map(b => b.name).join(', ')}`);
                }
            });
            
            // 모델을 위한 컨테이너 생성
            const container = new THREE.Group();
            container.add(model);
            container.visible = false;
            scene.add(container);
            
            // 컨테이너로 교체
            if (handType === 'left') {
                leftHandModel = container;
            } else {
                rightHandModel = container;
            }
        }
        
        // MediaPipe 초기화
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onHandsResults);
        
        // 웹캠 설정
        const video = document.getElementById('video');
        const camera_utils = new Camera(video, {
            onFrame: async () => {
                await hands.send({ image: video });
            },
            width: 640,
            height: 480
        });
        
        // FPS 계산
        let lastTime = performance.now();
        let frameCount = 0;
        
        // 손 추적 결과 처리
        function onHandsResults(results) {
            const currentTime = performance.now();
            frameCount++;
            
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // 모든 모델 숨기기
            if (leftHandModel) leftHandModel.visible = false;
            if (rightHandModel) rightHandModel.visible = false;
            
            // 모든 랜드마크 숨기기
            Object.values(leftHandJoints).forEach(joint => joint.visible = false);
            Object.values(rightHandJoints).forEach(joint => joint.visible = false);
            leftHandConnections.forEach(({ line }) => line.visible = false);
            rightHandConnections.forEach(({ line }) => line.visible = false);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('handDetected').textContent = `${results.multiHandLandmarks.length}개 감지됨`;
                document.getElementById('status').textContent = '손 추적 중...';
                
                // 각 손에 대해 처리
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    if (index < results.multiHandedness.length) {
                        const handedness = results.multiHandedness[index];
                        
                        // 첫 번째 손의 방향 표시
                        if (index === 0) {
                            document.getElementById('handedness').textContent = 
                                handedness.label === 'Left' ? '왼손' : '오른손';
                        }
                        
                        // 손 위치 업데이트
                        updateHandPosition(landmarks, handedness.label, index);
                    }
                });
            } else {
                document.getElementById('handDetected').textContent = '감지 안됨';
                document.getElementById('handedness').textContent = '-';
            }
        }
        
        // 3D 손 위치 업데이트
        function updateHandPosition(landmarks, handedness, handIndex) {
            const positions = [];
            
            // 랜드마크 위치 계산
            for (let i = 0; i < landmarks.length; i++) {
                const landmark = landmarks[i];
                
                // MediaPipe 좌표를 Three.js 좌표로 변환
                // 거울 효과를 제거하기 위해 x축을 반전
                const x = -(landmark.x - 0.5) * 1.0;  // x축 반전
                const y = -(landmark.y - 0.5) * 1.0;
                const z = -landmark.z * 0.3;
                
                positions.push(new THREE.Vector3(x, y, z));
                
                // 랜드마크 시각화 업데이트 (각 손별로 분리)
                if (showLandmarks) {
                    const isLeftHand = (handedness === 'Left');
                    const joints = isLeftHand ? leftHandJoints : rightHandJoints;
                    
                    if (joints[i]) {
                        joints[i].position.set(x, y, z);
                        joints[i].visible = true;
                    }
                }
                
                // 손목 위치 디버깅
                if (i === 0 && handIndex === 0) {
                    document.getElementById('wristPos').textContent = 
                        `x: ${x.toFixed(3)}, y: ${y.toFixed(3)}, z: ${z.toFixed(3)}`;
                }
            }
            
            // 연결선 업데이트 (각 손별로 분리)
            if (showLandmarks) {
                updateConnections(positions, handedness);
            }
            
            // GLB 모델 업데이트
            if (modelsLoaded) {
                // 거울 효과 제거: 실제 손과 같은 모델 사용
                const model = handedness === 'Left' ? leftHandModel : rightHandModel;
                if (model) {
                    model.visible = true;
                    updateGLBModel(model, positions, landmarks, handedness);
                }
            }
        }
        
        // 연결선 업데이트
        function updateConnections(positions, handedness) {
            const isLeftHand = (handedness === 'Left');
            const connections = isLeftHand ? leftHandConnections : rightHandConnections;
            
            connections.forEach(({ line, start, end }) => {
                if (positions[start] && positions[end]) {
                    const geometry = line.geometry;
                    const positionAttribute = geometry.attributes.position;
                    
                    positionAttribute.array[0] = positions[start].x;
                    positionAttribute.array[1] = positions[start].y;
                    positionAttribute.array[2] = positions[start].z;
                    positionAttribute.array[3] = positions[end].x;
                    positionAttribute.array[4] = positions[end].y;
                    positionAttribute.array[5] = positions[end].z;
                    
                    positionAttribute.needsUpdate = true;
                    line.visible = true;
                }
            });
        }
        
        // GLB 모델 업데이트
        function updateGLBModel(modelContainer, positions, landmarks, handedness) {
            if (!modelContainer || !modelContainer.children[0]) return;
            
            const model = modelContainer.children[0];
            
            // 손목 위치로 모델 이동
            modelContainer.position.copy(positions[0]);
            
            // 손에 따른 회전값과 스케일 선택
            const isLeftHand = (handedness === 'Left');
            const rotationX = isLeftHand ? leftHandRotationX : rightHandRotationX;
            const rotationY = isLeftHand ? leftHandRotationY : rightHandRotationY;
            const rotationZ = isLeftHand ? leftHandRotationZ : rightHandRotationZ;
            const scaleFactor = isLeftHand ? leftHandScaleFactor : rightHandScaleFactor;
            
            // 손 크기에 따른 스케일 조정 (좌우 반전 적용)
            const handScale = positions[0].distanceTo(positions[9]) * scaleFactor;
            model.scale.set(-handScale, -handScale, -handScale);
            
            // 손바닥 방향 계산
            const wrist = positions[0];
            const indexMCP = positions[5];
            const middleMCP = positions[9];
            const pinkyMCP = positions[17];
            
            // 손의 기본 축 계산
            // X축: 검지에서 새끼손가락 방향
            const handRight = new THREE.Vector3().subVectors(pinkyMCP, indexMCP).normalize();
            
            // Z축: 손목에서 중지 방향 (손바닥에서 나오는 방향)
            const middleFingerDir = new THREE.Vector3().subVectors(middleMCP, wrist);
            const indexDir = new THREE.Vector3().subVectors(indexMCP, wrist);
            const handForward = new THREE.Vector3().addVectors(middleFingerDir, indexDir).normalize();
            
            // Y축: X와 Z의 외적 (손가락이 향하는 방향)
            const handUp = new THREE.Vector3().crossVectors(handForward, handRight).normalize();
            
            // Z축 재계산 (정확한 직교 좌표계를 위해)
            const handNormal = new THREE.Vector3().crossVectors(handRight, handUp).normalize();
            
            // 회전 행렬 생성
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.set(
                handRight.x, handUp.x, handNormal.x, 0,
                handRight.y, handUp.y, handNormal.y, 0,
                handRight.z, handUp.z, handNormal.z, 0,
                0, 0, 0, 1
            );
            
            // 모델에 회전 적용
            modelContainer.quaternion.setFromRotationMatrix(rotationMatrix);
            
            // 사용자 정의 추가 회전 적용
            const additionalRotation = new THREE.Euler(
                THREE.Math.degToRad(rotationX),
                THREE.Math.degToRad(rotationY),
                THREE.Math.degToRad(rotationZ),
                'XYZ'
            );
            const additionalQuaternion = new THREE.Quaternion().setFromEuler(additionalRotation);
            modelContainer.quaternion.multiply(additionalQuaternion);
            
            // 손가락 관절 업데이트 (단순화된 버전)
            updateFingerJointsSimple(model, positions, landmarks);
        }
        
        // bone 매핑 성공 여부 확인
        function hasSuccessfulBoneMapping(model) {
            let mappedCount = 0;
            model.traverse((child) => {
                if (child.isBone && child.userData.landmarkMapped) {
                    mappedCount++;
                }
            });
            return mappedCount >= 10; // 최소 10개 이상의 bone이 매핑되어야 성공으로 간주
        }
        
        // 대안적인 손가락 애니메이션 방법
        function alternativeFingerAnimation(model, positions, landmarks) {
            // 메시의 정점들을 직접 변형하여 손가락 움직임 구현
            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const geometry = child.geometry;
                    const positionAttribute = geometry.attributes.position;
                    
                    if (positionAttribute) {
                        // 각 정점을 가장 가까운 랜드마크에 따라 변형
                        const vertices = positionAttribute.array;
                        const originalVertices = child.userData.originalVertices || vertices.slice();
                        
                        // 원본 정점 위치 저장 (첫 번째 실행 시)
                        if (!child.userData.originalVertices) {
                            child.userData.originalVertices = vertices.slice();
                        }
                        
                        for (let i = 0; i < vertices.length; i += 3) {
                            const vertex = new THREE.Vector3(
                                originalVertices[i],
                                originalVertices[i + 1],
                                originalVertices[i + 2]
                            );
                            
                            // 가장 가까운 랜드마크 찾기
                            let closestLandmark = 0;
                            let minDistance = Infinity;
                            
                            for (let j = 0; j < positions.length; j++) {
                                const distance = vertex.distanceTo(positions[j]);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestLandmark = j;
                                }
                            }
                            
                            // 랜드마크에 따른 변형 적용 (가중치 기반)
                            if (minDistance < 0.1) { // 임계값 내의 정점만 변형
                                const influence = Math.max(0, 1 - minDistance / 0.1);
                                const targetPos = positions[closestLandmark];
                                
                                vertex.lerp(targetPos, influence * 0.1); // 10% 영향도
                                
                                vertices[i] = vertex.x;
                                vertices[i + 1] = vertex.y;
                                vertices[i + 2] = vertex.z;
                            }
                        }
                        
                        positionAttribute.needsUpdate = true;
                        geometry.computeVertexNormals();
                    }
                }
            });
        }
        
        // 단순화된 손가락 관절 업데이트 (메시 변형 없이 bone만)
        function updateFingerJointsSimple(model, positions, landmarks) {
            if (!model || !positions || positions.length < 21) {
                return;
            }
            
            // 기본적인 bone 이름 매핑만 사용
            const simpleBoneMap = {
                // 엄지손가락
                1: ['thumb'],
                2: ['thumb'],
                3: ['thumb'],
                4: ['thumb'],
                
                // 검지손가락
                5: ['index'],
                6: ['index'],
                7: ['index'],
                8: ['index'],
                
                // 중지손가락
                9: ['middle'],
                10: ['middle'],
                11: ['middle'],
                12: ['middle'],
                
                // 약지손가락
                13: ['ring'],
                14: ['ring'],
                15: ['ring'],
                16: ['ring'],
                
                // 새끼손가락
                17: ['pinky', 'little'],
                18: ['pinky', 'little'],
                19: ['pinky', 'little'],
                20: ['pinky', 'little']
            };
            
            // bone을 찾아서 간단한 회전만 적용
            model.traverse((child) => {
                if (child.isBone) {
                    const boneName = child.name.toLowerCase();
                    
                    // 각 손가락에 대해 기본적인 회전만 적용
                    for (let landmarkIndex = 1; landmarkIndex < 21; landmarkIndex++) {
                        const fingerNames = simpleBoneMap[landmarkIndex];
                        if (fingerNames) {
                            const isMatch = fingerNames.some(name => boneName.includes(name));
                            
                            if (isMatch) {
                                // 손가락 굽힘 정도 계산 (간단한 버전)
                                const fingerTip = getFingerTip(landmarkIndex);
                                const fingerBase = getFingerBase(landmarkIndex);
                                
                                if (fingerTip && fingerBase && positions[fingerTip] && positions[fingerBase]) {
                                    const bendAmount = calculateFingerBend(positions[fingerBase], positions[fingerTip]);
                                    
                                    // 기본 회전에 굽힘 정도만 추가
                                    const baseRotation = child.userData.originalRotation || child.rotation.clone();
                                    child.userData.originalRotation = baseRotation;
                                    
                                    // X축 회전으로 손가락 굽힘 표현 (제한된 범위)
                                    const maxBend = Math.PI / 4; // 45도 제한
                                    const bendRotation = Math.max(-maxBend, Math.min(maxBend, bendAmount));
                                    
                                    child.rotation.x = baseRotation.x + bendRotation;
                                }
                                break;
                            }
                        }
                    }
                }
            });
        }
        
        // 손가락 끝점 랜드마크 인덱스 반환
        function getFingerTip(landmarkIndex) {
            if (landmarkIndex >= 1 && landmarkIndex <= 4) return 4;   // 엄지
            if (landmarkIndex >= 5 && landmarkIndex <= 8) return 8;   // 검지
            if (landmarkIndex >= 9 && landmarkIndex <= 12) return 12; // 중지
            if (landmarkIndex >= 13 && landmarkIndex <= 16) return 16; // 약지
            if (landmarkIndex >= 17 && landmarkIndex <= 20) return 20; // 새끼
            return null;
        }
        
        // 손가락 기준점 랜드마크 인덱스 반환
        function getFingerBase(landmarkIndex) {
            if (landmarkIndex >= 1 && landmarkIndex <= 4) return 1;   // 엄지
            if (landmarkIndex >= 5 && landmarkIndex <= 8) return 5;   // 검지
            if (landmarkIndex >= 9 && landmarkIndex <= 12) return 9;  // 중지
            if (landmarkIndex >= 13 && landmarkIndex <= 16) return 13; // 약지
            if (landmarkIndex >= 17 && landmarkIndex <= 20) return 17; // 새끼
            return null;
        }
        
        // 손가락 굽힘 정도 계산
        function calculateFingerBend(basePos, tipPos) {
            const distance = basePos.distanceTo(tipPos);
            const normalDistance = 0.1; // 정상적인 펼친 손가락 길이
            
            // 거리가 짧을수록 더 굽혀진 것
            const bendRatio = Math.max(0, Math.min(1, (normalDistance - distance) / normalDistance));
            return bendRatio * Math.PI / 3; // 최대 60도까지 굽힘
        }
        
        // 복잡한 bone 매핑 함수는 주석 처리 (나중에 필요시 사용)
        /*
        // 손가락 관절 업데이트 - 개선된 bone 매핑
        function updateFingerJoints(model, positions, landmarks) {
            if (!model || !positions || positions.length < 21) {
                return;
            }
            
            // 확장된 bone 이름 매핑 (더 많은 가능한 이름들 포함)
            const landmarkToBoneMap = {
                // 손목
                0: ['wrist', 'hand', 'palm', 'root'],
                
                // 엄지손가락 (Thumb) - 더 많은 변형 추가
                1: ['thumb_mcp', 'thumb_0', 'thumb1', 'thumb.01', 'thumb_01', 'thumb_meta', 'thumb_metacarpal'],
                2: ['thumb_pip', 'thumb_1', 'thumb2', 'thumb.02', 'thumb_02', 'thumb_proximal'],
                3: ['thumb_dip', 'thumb_2', 'thumb3', 'thumb.03', 'thumb_03', 'thumb_distal'],
                4: ['thumb_tip', 'thumb_3', 'thumb4', 'thumb.04', 'thumb_04', 'thumb_end'],
                
                // 검지손가락 (Index) - 더 많은 변형 추가
                5: ['index_mcp', 'index_0', 'index1', 'index.01', 'index_01', 'finger_index_meta', 'finger_index_1'],
                6: ['index_pip', 'index_1', 'index2', 'index.02', 'index_02', 'finger_index_a', 'finger_index_2'],
                7: ['index_dip', 'index_2', 'index3', 'index.03', 'index_03', 'finger_index_b', 'finger_index_3'],
                8: ['index_tip', 'index_3', 'index4', 'index.04', 'index_04', 'finger_index_c', 'finger_index_4'],
                
                // 중지손가락 (Middle) - 더 많은 변형 추가
                9: ['middle_mcp', 'middle_0', 'middle1', 'middle.01', 'middle_01', 'finger_middle_meta', 'finger_middle_1'],
                10: ['middle_pip', 'middle_1', 'middle2', 'middle.02', 'middle_02', 'finger_middle_a', 'finger_middle_2'],
                11: ['middle_dip', 'middle_2', 'middle3', 'middle.03', 'middle_03', 'finger_middle_b', 'finger_middle_3'],
                12: ['middle_tip', 'middle_3', 'middle4', 'middle.04', 'middle_04', 'finger_middle_c', 'finger_middle_4'],
                
                // 약지손가락 (Ring) - 더 많은 변형 추가
                13: ['ring_mcp', 'ring_0', 'ring1', 'ring.01', 'ring_01', 'finger_ring_meta', 'finger_ring_1'],
                14: ['ring_pip', 'ring_1', 'ring2', 'ring.02', 'ring_02', 'finger_ring_a', 'finger_ring_2'],
                15: ['ring_dip', 'ring_2', 'ring3', 'ring.03', 'ring_03', 'finger_ring_b', 'finger_ring_3'],
                16: ['ring_tip', 'ring_3', 'ring4', 'ring.04', 'ring_04', 'finger_ring_c', 'finger_ring_4'],
                
                // 새끼손가락 (Pinky) - 더 많은 변형 추가
                17: ['pinky_mcp', 'pinky_0', 'pinky1', 'pinky.01', 'pinky_01', 'little_mcp', 'little_0', 'finger_pinky_meta', 'finger_pinky_1'],
                18: ['pinky_pip', 'pinky_1', 'pinky2', 'pinky.02', 'pinky_02', 'little_pip', 'little_1', 'finger_pinky_a', 'finger_pinky_2'],
                19: ['pinky_dip', 'pinky_2', 'pinky3', 'pinky.03', 'pinky_03', 'little_dip', 'little_2', 'finger_pinky_b', 'finger_pinky_3'],
                20: ['pinky_tip', 'pinky_3', 'pinky4', 'pinky.04', 'pinky_04', 'little_tip', 'little_3', 'finger_pinky_c', 'finger_pinky_4']
            };
            
            // bone 매핑 결과 저장
            const boneMap = new Map();
            
            // 1단계: 모든 bone을 수집하고 매핑
            model.traverse((child) => {
                if (child.isBone) {
                    const boneName = child.name.toLowerCase();
                    console.log(`Found bone: "${child.name}"`);
                    
                    // 각 랜드마크에 대해 매칭 확인
                    for (let landmarkIndex = 0; landmarkIndex < 21; landmarkIndex++) {
                        const possibleNames = landmarkToBoneMap[landmarkIndex];
                        if (possibleNames) {
                            const isMatch = possibleNames.some(name => {
                                // 정확한 매칭 또는 부분 매칭 확인
                                return boneName === name || 
                                       boneName.includes(name) || 
                                       name.includes(boneName) ||
                                       boneName.replace(/[._-]/g, '') === name.replace(/[._-]/g, '');
                            });
                            
                            if (isMatch) {
                                boneMap.set(landmarkIndex, child);
                                console.log(`✓ Bone "${child.name}" mapped to landmark ${landmarkIndex}`);
                                break;
                            }
                        }
                    }
                }
            });
            
            // 2단계: 매핑된 bone들에 대해 애니메이션 적용
            boneMap.forEach((bone, landmarkIndex) => {
                if (positions[landmarkIndex]) {
                    // 매핑 성공 표시
                    bone.userData.landmarkMapped = true;
                    
                    const landmarkPos = positions[landmarkIndex];
                    
                    // bone 위치를 랜드마크 위치로 직접 설정 (스케일 고려)
                    const scaleFactor = 0.1; // GLB 모델 스케일에 맞게 조정
                    const targetPos = landmarkPos.clone().multiplyScalar(scaleFactor);
                    
                    // 상대적 위치로 설정 (부모 bone 고려)
                    if (bone.parent && bone.parent.isBone) {
                        // 부모로부터의 상대 위치 계산
                        const parentWorldPos = new THREE.Vector3();
                        bone.parent.getWorldPosition(parentWorldPos);
                        const relativePos = targetPos.clone().sub(parentWorldPos);
                        bone.position.copy(relativePos);
                    } else {
                        bone.position.copy(targetPos);
                    }
                    
                    // 손가락 관절의 회전 계산 (다음 관절을 향하도록)
                    const nextIndex = getNextLandmarkIndex(landmarkIndex);
                    if (nextIndex && positions[nextIndex] && boneMap.has(nextIndex)) {
                        const currentPos = positions[landmarkIndex];
                        const nextPos = positions[nextIndex];
                        
                        // 다음 관절 방향으로의 벡터 계산
                        const direction = new THREE.Vector3()
                            .subVectors(nextPos, currentPos)
                            .normalize();
                        
                        if (direction.length() > 0.01) { // 충분한 거리가 있을 때만
                            // 기본 방향을 다음 관절 방향으로 회전
                            const defaultDirection = new THREE.Vector3(0, 1, 0); // Y축 기본 방향
                            const quaternion = new THREE.Quaternion();
                            quaternion.setFromUnitVectors(defaultDirection, direction);
                            bone.quaternion.copy(quaternion);
                        }
                    }
                }
            });
            
            // 디버그: 매핑되지 않은 랜드마크 출력
            for (let i = 0; i < 21; i++) {
                if (!boneMap.has(i)) {
                    console.warn(`⚠ Landmark ${i} has no corresponding bone`);
                }
            }
        }
        
        // 다음 랜드마크 인덱스를 반환하는 헬퍼 함수
        function getNextLandmarkIndex(currentIndex) {
            const fingerChains = {
                // 엄지: 1->2->3->4
                1: 2, 2: 3, 3: 4,
                // 검지: 5->6->7->8
                5: 6, 6: 7, 7: 8,
                // 중지: 9->10->11->12
                9: 10, 10: 11, 11: 12,
                // 약지: 13->14->15->16
                13: 14, 14: 15, 15: 16,
                // 새끼: 17->18->19->20
                17: 18, 18: 19, 19: 20
            };
            
            return fingerChains[currentIndex] || null;
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // 이벤트 리스너
        document.getElementById('showLandmarks').addEventListener('change', (e) => {
            showLandmarks = e.target.checked;
            saveSettings(); // 자동 저장
        });
        
        // 저장/리셋 버튼 이벤트
        document.getElementById('saveSettings').addEventListener('click', () => {
            saveSettings();
            alert('설정이 저장되었습니다!');
        });
        
        document.getElementById('resetSettings').addEventListener('click', () => {
            if (confirm('모든 설정을 기본값으로 되돌리시겠습니까?')) {
                // 기본값으로 리셋
                leftHandRotationX = 0;
                leftHandRotationY = 73;
                leftHandRotationZ = 0;
                leftHandScaleFactor = 11;
                rightHandRotationX = -180;
                rightHandRotationY = -73;
                rightHandRotationZ = 0;
                rightHandScaleFactor = 11;
                showLandmarks = true;
                
                updateSliderValues();
                saveSettings();
                alert('설정이 기본값으로 복원되었습니다!');
            }
        });
        
        // 왼손 회전 컨트롤
        document.getElementById('leftRotationX').addEventListener('input', (e) => {
            leftHandRotationX = parseFloat(e.target.value);
            document.getElementById('leftRotationXValue').textContent = leftHandRotationX + '°';
            saveSettings(); // 자동 저장
        });
        
        document.getElementById('leftRotationY').addEventListener('input', (e) => {
            leftHandRotationY = parseFloat(e.target.value);
            document.getElementById('leftRotationYValue').textContent = leftHandRotationY + '°';
            saveSettings(); // 자동 저장
        });
        
        document.getElementById('leftRotationZ').addEventListener('input', (e) => {
            leftHandRotationZ = parseFloat(e.target.value);
            document.getElementById('leftRotationZValue').textContent = leftHandRotationZ + '°';
            saveSettings(); // 자동 저장
        });
        
        document.getElementById('leftModelScale').addEventListener('input', (e) => {
            leftHandScaleFactor = parseFloat(e.target.value);
            document.getElementById('leftModelScaleValue').textContent = leftHandScaleFactor.toFixed(1);
            saveSettings(); // 자동 저장
        });
        
        // 오른손 회전 컨트롤
        document.getElementById('rightRotationX').addEventListener('input', (e) => {
            rightHandRotationX = parseFloat(e.target.value);
            document.getElementById('rightRotationXValue').textContent = rightHandRotationX + '°';
            saveSettings(); // 자동 저장
        });
        
        document.getElementById('rightRotationY').addEventListener('input', (e) => {
            rightHandRotationY = parseFloat(e.target.value);
            document.getElementById('rightRotationYValue').textContent = rightHandRotationY + '°';
            saveSettings(); // 자동 저장
        });
        
        document.getElementById('rightRotationZ').addEventListener('input', (e) => {
            rightHandRotationZ = parseFloat(e.target.value);
            document.getElementById('rightRotationZValue').textContent = rightHandRotationZ + '°';
            saveSettings(); // 자동 저장
        });
        
        document.getElementById('rightModelScale').addEventListener('input', (e) => {
            rightHandScaleFactor = parseFloat(e.target.value);
            document.getElementById('rightModelScaleValue').textContent = rightHandScaleFactor.toFixed(1);
            saveSettings(); // 자동 저장
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 초기화
        loadSettings(); // 저장된 설정 불러오기
        initThreeJS();
        camera_utils.start();
        document.getElementById('status').textContent = '카메라 준비 완료';
    </script>
</body>
</html>