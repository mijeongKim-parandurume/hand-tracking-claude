<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Hand Tracking with GLB Models</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
            position: relative;
        }
        
        #videoContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #canvas3d {
            width: 100%;
            height: 100%;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 10;
            max-width: 350px;
        }
        
        #status {
            color: #00ff00;
            margin-top: 10px;
        }
        
        .landmark-info {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
        
        .debug-info {
            margin-top: 10px;
            font-size: 11px;
            color: #aaa;
            font-family: monospace;
        }
        
        .rotation-controls {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        
        .rotation-controls h4 {
            margin: 0 0 10px 0;
            color: #00ff00;
            font-size: 12px;
        }
        
        .rotation-control {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 11px;
        }
        
        .rotation-control label {
            width: 80px;
            color: #ccc;
        }
        
        .rotation-control input[type="range"] {
            width: 150px;
            margin: 0 10px;
        }
        
        .rotation-control span {
            width: 60px;
            color: #00ff00;
            font-family: monospace;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #00ff00;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas3d"></canvas>
        <div id="videoContainer">
            <video id="video" playsinline></video>
        </div>
        <div id="info">
            <h3>MediaPipe Hand Tracking</h3>
            <div id="status">ì´ˆê¸°í™” ì¤‘...</div>
            <div class="landmark-info">
                ì† ê°ì§€: <span id="handDetected">-</span><br>
                ì† ë°©í–¥: <span id="handedness">-</span><br>
                FPS: <span id="fps">0</span>
            </div>
            <div class="debug-info">
                ì†ëª© ìœ„ì¹˜: <span id="wristPos">-</span><br>
                ëª¨ë¸ ìƒíƒœ: <span id="modelStatus">ëª¨ë¸ ë¡œë”© ì¤‘...</span><br>
                Bone ë§¤í•‘: <span id="boneMapping">-</span><br>
                ë§¤í•‘ í’ˆì§ˆ: <span id="mappingQuality">-</span>
            </div>
            <div class="toggle-switch">
                <label>ëœë“œë§ˆí¬ í‘œì‹œ:</label>
                <label class="switch">
                    <input type="checkbox" id="showLandmarks" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button id="saveSettings" style="padding: 8px 16px; background: #00ff00; color: #000; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">ì„¤ì • ì €ì¥</button>
                <button id="resetSettings" style="padding: 8px 16px; background: #ff6666; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">ê¸°ë³¸ê°’ ë³µì›</button>
            </div>
            <div class="rotation-controls">
                <h4>ì™¼ì† ëª¨ë¸ ì¡°ì •</h4>
                <div class="rotation-control">
                    <label>Xì¶• íšŒì „:</label>
                    <input type="range" id="leftRotationX" min="-180" max="180" value="0" step="1">
                    <span id="leftRotationXValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>Yì¶• íšŒì „:</label>
                    <input type="range" id="leftRotationY" min="-180" max="180" value="0" step="1">
                    <span id="leftRotationYValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>Zì¶• íšŒì „:</label>
                    <input type="range" id="leftRotationZ" min="-180" max="180" value="0" step="1">
                    <span id="leftRotationZValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>ìŠ¤ì¼€ì¼:</label>
                    <input type="range" id="leftModelScale" min="1" max="20" value="8" step="0.5">
                    <span id="leftModelScaleValue">8.0</span>
                </div>
                <div class="rotation-control">
                    <label>ì—„ì§€ Xì¶•:</label>
                    <input type="range" id="leftThumbRotationX" min="-180" max="180" value="0" step="1">
                    <span id="leftThumbRotationXValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>ì—„ì§€ Yì¶•:</label>
                    <input type="range" id="leftThumbRotationY" min="-180" max="180" value="0" step="1">
                    <span id="leftThumbRotationYValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>ì—„ì§€ Zì¶•:</label>
                    <input type="range" id="leftThumbRotationZ" min="-180" max="180" value="0" step="1">
                    <span id="leftThumbRotationZValue">0Â°</span>
                </div>
            </div>
            <div class="rotation-controls">
                <h4>ì˜¤ë¥¸ì† ëª¨ë¸ ì¡°ì •</h4>
                <div class="rotation-control">
                    <label>Xì¶• íšŒì „:</label>
                    <input type="range" id="rightRotationX" min="-180" max="180" value="0" step="1">
                    <span id="rightRotationXValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>Yì¶• íšŒì „:</label>
                    <input type="range" id="rightRotationY" min="-180" max="180" value="0" step="1">
                    <span id="rightRotationYValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>Zì¶• íšŒì „:</label>
                    <input type="range" id="rightRotationZ" min="-180" max="180" value="0" step="1">
                    <span id="rightRotationZValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>ìŠ¤ì¼€ì¼:</label>
                    <input type="range" id="rightModelScale" min="1" max="20" value="8" step="0.5">
                    <span id="rightModelScaleValue">8.0</span>
                </div>
                <div class="rotation-control">
                    <label>ì—„ì§€ Xì¶•:</label>
                    <input type="range" id="rightThumbRotationX" min="-180" max="180" value="0" step="1">
                    <span id="rightThumbRotationXValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>ì—„ì§€ Yì¶•:</label>
                    <input type="range" id="rightThumbRotationY" min="-180" max="180" value="0" step="1">
                    <span id="rightThumbRotationYValue">0Â°</span>
                </div>
                <div class="rotation-control">
                    <label>ì—„ì§€ Zì¶•:</label>
                    <input type="range" id="rightThumbRotationZ" min="-180" max="180" value="0" step="1">
                    <span id="rightThumbRotationZValue">0Â°</span>
                </div>
            </div>
        </div>
        <div class="loading" id="loading">GLB ëª¨ë¸ ë¡œë”© ì¤‘...</div>
    </div>

    <!-- MediaPipe CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Three.js ì„¤ì •
        let scene, camera, renderer;
        let leftHandModel = null;
        let rightHandModel = null;
        let currentHandModel = null;
        let leftHandJoints = {};
        let rightHandJoints = {};
        let leftHandConnections = [];
        let rightHandConnections = [];
        let showLandmarks = true;
        let modelsLoaded = false;
        
        // ì™¼ì† íšŒì „ ì¡°ì •ê°’
        let leftHandRotationX = 0;
        let leftHandRotationY = 0;
        let leftHandRotationZ = 0;
        let leftHandScaleFactor = 11;
        let leftThumbRotationX = 0; // ì™¼ì† ì—„ì§€ Xì¶• íšŒì „
        let leftThumbRotationY = 0; // ì™¼ì† ì—„ì§€ Yì¶• íšŒì „
        let leftThumbRotationZ = 0; // ì™¼ì† ì—„ì§€ Zì¶• íšŒì „
        
        // ì˜¤ë¥¸ì† íšŒì „ ì¡°ì •ê°’
        let rightHandRotationX = 0;
        let rightHandRotationY = 0;
        let rightHandRotationZ = 0;
        let rightHandScaleFactor = 11;
        let rightThumbRotationX = 0; // ì˜¤ë¥¸ì† ì—„ì§€ Xì¶• íšŒì „
        let rightThumbRotationY = 0; // ì˜¤ë¥¸ì† ì—„ì§€ Yì¶• íšŒì „
        let rightThumbRotationZ = 0; // ì˜¤ë¥¸ì† ì—„ì§€ Zì¶• íšŒì „
        
        // GLB íŒŒì¼ ê²½ë¡œ ì„¤ì •
        const MODEL_PATH = './Models/';
        const LEFT_HAND_MODEL = MODEL_PATH + 'LeftHand.glb';
        const RIGHT_HAND_MODEL = MODEL_PATH + 'RightHand.glb';
        
        // ì„¤ì •ê°’ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜ë“¤
        function saveSettings() {
            const settings = {
                leftHandRotationX,
                leftHandRotationY,
                leftHandRotationZ,
                leftHandScaleFactor,
                leftThumbRotationX,
                leftThumbRotationY,
                leftThumbRotationZ,
                rightHandRotationX,
                rightHandRotationY,
                rightHandRotationZ,
                rightHandScaleFactor,
                rightThumbRotationX,
                rightThumbRotationY,
                rightThumbRotationZ,
                showLandmarks
            };
            localStorage.setItem('handTrackingSettings', JSON.stringify(settings));
            console.log('ì„¤ì •ê°’ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
        
        function loadSettings() {
            const savedSettings = localStorage.getItem('handTrackingSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    
                    // ì™¼ì† ëª¨ë¸ ì„¤ì • ì ìš©
                    leftHandRotationX = settings.leftHandRotationX || 0;
                    leftHandRotationY = settings.leftHandRotationY || 0;
                    leftHandRotationZ = settings.leftHandRotationZ || 0;
                    leftHandScaleFactor = settings.leftHandScaleFactor || 11;
                    leftThumbRotationX = settings.leftThumbRotationX || 0;
                    leftThumbRotationY = settings.leftThumbRotationY || 0;
                    leftThumbRotationZ = settings.leftThumbRotationZ || 0;
                    
                    // ì˜¤ë¥¸ì† ëª¨ë¸ ì„¤ì • ì ìš©
                    rightHandRotationX = settings.rightHandRotationX || 0;
                    rightHandRotationY = settings.rightHandRotationY || 0;
                    rightHandRotationZ = settings.rightHandRotationZ || 0;
                    rightHandScaleFactor = settings.rightHandScaleFactor || 11;
                    rightThumbRotationX = settings.rightThumbRotationX || 0;
                    rightThumbRotationY = settings.rightThumbRotationY || 0;
                    rightThumbRotationZ = settings.rightThumbRotationZ || 0;
                    
                    // ëœë“œë§ˆí¬ í‘œì‹œ ì„¤ì •
                    showLandmarks = settings.showLandmarks !== undefined ? settings.showLandmarks : true;
                    
                    // UI ì—…ë°ì´íŠ¸
                    updateSliderValues();
                    
                    console.log('ì„¤ì •ê°’ì´ ë¶ˆëŸ¬ì™€ì¡ŒìŠµë‹ˆë‹¤.');
                } catch (error) {
                    console.error('ì„¤ì •ê°’ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
                }
            }
        }
        
        function updateSliderValues() {
            // ì™¼ì† ëª¨ë¸ ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
            document.getElementById('leftRotationX').value = leftHandRotationX;
            document.getElementById('leftRotationXValue').textContent = leftHandRotationX + 'Â°';
            document.getElementById('leftRotationY').value = leftHandRotationY;
            document.getElementById('leftRotationYValue').textContent = leftHandRotationY + 'Â°';
            document.getElementById('leftRotationZ').value = leftHandRotationZ;
            document.getElementById('leftRotationZValue').textContent = leftHandRotationZ + 'Â°';
            document.getElementById('leftModelScale').value = leftHandScaleFactor;
            document.getElementById('leftModelScaleValue').textContent = leftHandScaleFactor.toFixed(1);
            document.getElementById('leftThumbRotationX').value = leftThumbRotationX;
            document.getElementById('leftThumbRotationXValue').textContent = leftThumbRotationX + 'Â°';
            document.getElementById('leftThumbRotationY').value = leftThumbRotationY;
            document.getElementById('leftThumbRotationYValue').textContent = leftThumbRotationY + 'Â°';
            document.getElementById('leftThumbRotationZ').value = leftThumbRotationZ;
            document.getElementById('leftThumbRotationZValue').textContent = leftThumbRotationZ + 'Â°';
            
            // ì˜¤ë¥¸ì† ëª¨ë¸ ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
            document.getElementById('rightRotationX').value = rightHandRotationX;
            document.getElementById('rightRotationXValue').textContent = rightHandRotationX + 'Â°';
            document.getElementById('rightRotationY').value = rightHandRotationY;
            document.getElementById('rightRotationYValue').textContent = rightHandRotationY + 'Â°';
            document.getElementById('rightRotationZ').value = rightHandRotationZ;
            document.getElementById('rightRotationZValue').textContent = rightHandRotationZ + 'Â°';
            document.getElementById('rightModelScale').value = rightHandScaleFactor;
            document.getElementById('rightModelScaleValue').textContent = rightHandScaleFactor.toFixed(1);
            document.getElementById('rightThumbRotationX').value = rightThumbRotationX;
            document.getElementById('rightThumbRotationXValue').textContent = rightThumbRotationX + 'Â°';
            document.getElementById('rightThumbRotationY').value = rightThumbRotationY;
            document.getElementById('rightThumbRotationYValue').textContent = rightThumbRotationY + 'Â°';
            document.getElementById('rightThumbRotationZ').value = rightThumbRotationZ;
            document.getElementById('rightThumbRotationZValue').textContent = rightThumbRotationZ + 'Â°';
            
            // ëœë“œë§ˆí¬ ì²´í¬ë°•ìŠ¤ ì—…ë°ì´íŠ¸
            document.getElementById('showLandmarks').checked = showLandmarks;
        }
        
        // MediaPipe ëœë“œë§ˆí¬ì™€ bone ë§¤í•‘ ì •ì˜
        const MEDIAPIPE_LANDMARK_NAMES = [
            'WRIST',           // 0
            'THUMB_CMC',       // 1
            'THUMB_MCP',       // 2
            'THUMB_IP',        // 3
            'THUMB_TIP',       // 4
            'INDEX_FINGER_MCP', // 5
            'INDEX_FINGER_PIP', // 6
            'INDEX_FINGER_DIP', // 7
            'INDEX_FINGER_TIP', // 8
            'MIDDLE_FINGER_MCP', // 9
            'MIDDLE_FINGER_PIP', // 10
            'MIDDLE_FINGER_DIP', // 11
            'MIDDLE_FINGER_TIP', // 12
            'RING_FINGER_MCP',  // 13
            'RING_FINGER_PIP',  // 14
            'RING_FINGER_DIP',  // 15
            'RING_FINGER_TIP',  // 16
            'PINKY_MCP',       // 17
            'PINKY_PIP',       // 18
            'PINKY_DIP',       // 19
            'PINKY_TIP'        // 20
        ];
        
        // GLB ëª¨ë¸ì˜ boneê³¼ MediaPipe ëœë“œë§ˆí¬ ë§¤í•‘ (í™•ì¥ëœ íŒ¨í„´)
        const BONE_TO_LANDMARK_MAPPING = {
            // ì†ëª©/ì†ë°”ë‹¥
            'wrist': 0,
            'hand': 0,
            'palm': 0,
            'root': 0,
            'armature': 0,
            'hand_l': 0,
            'hand_r': 0,
            
            // ì—„ì§€ì†ê°€ë½ (ë‹¤ì–‘í•œ ëª…ëª… íŒ¨í„´)
            'thumb_01': 1, 'thumb_1': 1, 'thumb1': 1, 'thumb_cmc': 1, 'thumb.01': 1,
            'thumb_02': 2, 'thumb_2': 2, 'thumb2': 2, 'thumb_mcp': 2, 'thumb.02': 2,
            'thumb_03': 3, 'thumb_3': 3, 'thumb3': 3, 'thumb_ip': 3, 'thumb.03': 3,
            'thumb_04': 4, 'thumb_4': 4, 'thumb4': 4, 'thumb_tip': 4, 'thumb.04': 4,
            'thumb_end': 4, 'thumbtip': 4,
            
            // ê²€ì§€ì†ê°€ë½
            'index_01': 5, 'index_1': 5, 'index1': 5, 'index_mcp': 5, 'index.01': 5,
            'index_02': 6, 'index_2': 6, 'index2': 6, 'index_pip': 6, 'index.02': 6,
            'index_03': 7, 'index_3': 7, 'index3': 7, 'index_dip': 7, 'index.03': 7,
            'index_04': 8, 'index_4': 8, 'index4': 8, 'index_tip': 8, 'index.04': 8,
            'index_end': 8, 'indextip': 8, 'indexfinger': 5,
            
            // ì¤‘ì§€ì†ê°€ë½
            'middle_01': 9, 'middle_1': 9, 'middle1': 9, 'middle_mcp': 9, 'middle.01': 9,
            'middle_02': 10, 'middle_2': 10, 'middle2': 10, 'middle_pip': 10, 'middle.02': 10,
            'middle_03': 11, 'middle_3': 11, 'middle3': 11, 'middle_dip': 11, 'middle.03': 11,
            'middle_04': 12, 'middle_4': 12, 'middle4': 12, 'middle_tip': 12, 'middle.04': 12,
            'middle_end': 12, 'middletip': 12, 'middlefinger': 9,
            
            // ì•½ì§€ì†ê°€ë½
            'ring_01': 13, 'ring_1': 13, 'ring1': 13, 'ring_mcp': 13, 'ring.01': 13,
            'ring_02': 14, 'ring_2': 14, 'ring2': 14, 'ring_pip': 14, 'ring.02': 14,
            'ring_03': 15, 'ring_3': 15, 'ring3': 15, 'ring_dip': 15, 'ring.03': 15,
            'ring_04': 16, 'ring_4': 16, 'ring4': 16, 'ring_tip': 16, 'ring.04': 16,
            'ring_end': 16, 'ringtip': 16, 'ringfinger': 13,
            
            // ìƒˆë¼ì†ê°€ë½
            'pinky_01': 17, 'pinky_1': 17, 'pinky1': 17, 'pinky_mcp': 17, 'pinky.01': 17,
            'pinky_02': 18, 'pinky_2': 18, 'pinky2': 18, 'pinky_pip': 18, 'pinky.02': 18,
            'pinky_03': 19, 'pinky_3': 19, 'pinky3': 19, 'pinky_dip': 19, 'pinky.03': 19,
            'pinky_04': 20, 'pinky_4': 20, 'pinky4': 20, 'pinky_tip': 20, 'pinky.04': 20,
            'pinky_end': 20, 'pinkytip': 20, 'pinkyfinger': 17,
            
            // ëŒ€ì²´ ì´ë¦„ (little finger)
            'little_01': 17, 'little_1': 17, 'little1': 17, 'little_mcp': 17, 'little.01': 17,
            'little_02': 18, 'little_2': 18, 'little2': 18, 'little_pip': 18, 'little.02': 18,
            'little_03': 19, 'little_3': 19, 'little3': 19, 'little_dip': 19, 'little.03': 19,
            'little_04': 20, 'little_4': 20, 'little4': 20, 'little_tip': 20, 'little.04': 20,
            'little_end': 20, 'littletip': 20, 'littlefinger': 17,
            
            // Blender ìŠ¤íƒ€ì¼ ì´ë¦„
            'finger_index': 5, 'finger_middle': 9, 'finger_ring': 13, 'finger_pinky': 17,
            'finger_thumb': 1,
            
            // Maya/3ds Max ìŠ¤íƒ€ì¼ ì´ë¦„
            'l_hand': 0, 'r_hand': 0, 'l_wrist': 0, 'r_wrist': 0,
            'l_thumb1': 1, 'l_thumb2': 2, 'l_thumb3': 3, 'l_thumb4': 4,
            'r_thumb1': 1, 'r_thumb2': 2, 'r_thumb3': 3, 'r_thumb4': 4,
            'l_index1': 5, 'l_index2': 6, 'l_index3': 7, 'l_index4': 8,
            'r_index1': 5, 'r_index2': 6, 'r_index3': 7, 'r_index4': 8,
            'l_middle1': 9, 'l_middle2': 10, 'l_middle3': 11, 'l_middle4': 12,
            'r_middle1': 9, 'r_middle2': 10, 'r_middle3': 11, 'r_middle4': 12,
            'l_ring1': 13, 'l_ring2': 14, 'l_ring3': 15, 'l_ring4': 16,
            'r_ring1': 13, 'r_ring2': 14, 'r_ring3': 15, 'r_ring4': 16,
            'l_pinky1': 17, 'l_pinky2': 18, 'l_pinky3': 19, 'l_pinky4': 20,
            'r_pinky1': 17, 'r_pinky2': 18, 'r_pinky3': 19, 'r_pinky4': 20
        };
        
        // boneê³¼ ëœë“œë§ˆí¬ ë§¤í•‘ í•¨ìˆ˜ (í–¥ìƒëœ ë²„ì „)
        function getBoneToLandmarkMapping(boneName) {
            const lowerBoneName = boneName.toLowerCase()
                .replace(/\s+/g, '_')  // ê³µë°±ì„ ì–¸ë”ìŠ¤ì½”ì–´ë¡œ
                .replace(/[.\-]/g, '_'); // ì ê³¼ í•˜ì´í”ˆì„ ì–¸ë”ìŠ¤ì½”ì–´ë¡œ
            
            // ì •í™•í•œ ë§¤ì¹­ ì‹œë„
            if (BONE_TO_LANDMARK_MAPPING[lowerBoneName] !== undefined) {
                return BONE_TO_LANDMARK_MAPPING[lowerBoneName];
            }
            
            // ë¶€ë¶„ ë§¤ì¹­ ì‹œë„ (ë” ì •í™•í•œ ë°©ì‹)
            for (const [key, value] of Object.entries(BONE_TO_LANDMARK_MAPPING)) {
                if (lowerBoneName.includes(key) || key.includes(lowerBoneName)) {
                    return value;
                }
            }
            
            // íŒ¨í„´ ê¸°ë°˜ ë§¤ì¹­ ì‹œë„
            const patterns = [
                // ì—„ì§€
                { regex: /thumb.*[_.]?0?1/i, landmark: 1 },
                { regex: /thumb.*[_.]?0?2/i, landmark: 2 },
                { regex: /thumb.*[_.]?0?3/i, landmark: 3 },
                { regex: /thumb.*[_.]?0?4/i, landmark: 4 },
                { regex: /thumb/i, landmark: 1 },
                
                // ê²€ì§€
                { regex: /index.*[_.]?0?1/i, landmark: 5 },
                { regex: /index.*[_.]?0?2/i, landmark: 6 },
                { regex: /index.*[_.]?0?3/i, landmark: 7 },
                { regex: /index.*[_.]?0?4/i, landmark: 8 },
                { regex: /index/i, landmark: 5 },
                
                // ì¤‘ì§€
                { regex: /middle.*[_.]?0?1/i, landmark: 9 },
                { regex: /middle.*[_.]?0?2/i, landmark: 10 },
                { regex: /middle.*[_.]?0?3/i, landmark: 11 },
                { regex: /middle.*[_.]?0?4/i, landmark: 12 },
                { regex: /middle/i, landmark: 9 },
                
                // ì•½ì§€
                { regex: /ring.*[_.]?0?1/i, landmark: 13 },
                { regex: /ring.*[_.]?0?2/i, landmark: 14 },
                { regex: /ring.*[_.]?0?3/i, landmark: 15 },
                { regex: /ring.*[_.]?0?4/i, landmark: 16 },
                { regex: /ring/i, landmark: 13 },
                
                // ìƒˆë¼
                { regex: /(pinky|little).*[_.]?0?1/i, landmark: 17 },
                { regex: /(pinky|little).*[_.]?0?2/i, landmark: 18 },
                { regex: /(pinky|little).*[_.]?0?3/i, landmark: 19 },
                { regex: /(pinky|little).*[_.]?0?4/i, landmark: 20 },
                { regex: /(pinky|little)/i, landmark: 17 },
                
                // ì†ëª©/ì†ë°”ë‹¥
                { regex: /(wrist|hand|palm|root)/i, landmark: 0 }
            ];
            
            for (const pattern of patterns) {
                if (pattern.regex.test(boneName)) {
                    return pattern.landmark;
                }
            }
            
            return -1; // ë§¤í•‘ë˜ì§€ ì•ŠìŒ
        }
        
        // MediaPipe ëœë“œë§ˆí¬ ì—°ê²°ì„  ì •ì˜
        const LANDMARK_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],         // ì—„ì§€
            [0, 5], [5, 6], [6, 7], [7, 8],         // ê²€ì§€
            [0, 9], [9, 10], [10, 11], [11, 12],    // ì¤‘ì§€
            [0, 13], [13, 14], [14, 15], [15, 16],  // ì•½ì§€
            [0, 17], [17, 18], [18, 19], [19, 20],  // ìƒˆë¼
            [5, 9], [9, 13], [13, 17]               // ì†ë°”ë‹¥
        ];
        
        // Three.js ì´ˆê¸°í™”
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // ì¹´ë©”ë¼ ì„¤ì •
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 0, 0.5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas3d'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // ì¡°ëª… ì„¤ì •
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // ëœë“œë§ˆí¬ ì‹œê°í™” ìƒì„±
            createLandmarkVisualization();
            
            // GLB ëª¨ë¸ ìë™ ë¡œë“œ
            loadModels();
            
            animate();
        }
        
        // ëœë“œë§ˆí¬ ì‹œê°í™” ìƒì„±
        function createLandmarkVisualization() {
            // ì™¼ì† ëœë“œë§ˆí¬ êµ¬ì²´ ìƒì„±
            const leftSphereGeometry = new THREE.SphereGeometry(0.008, 16, 16);
            const leftSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.8
            });
            
            for (let i = 0; i < 21; i++) {
                const sphere = new THREE.Mesh(leftSphereGeometry, leftSphereMaterial);
                sphere.name = `left_landmark_${i}`;
                sphere.visible = false;
                scene.add(sphere);
                leftHandJoints[i] = sphere;
            }
            
            // ì˜¤ë¥¸ì† ëœë“œë§ˆí¬ êµ¬ì²´ ìƒì„±
            const rightSphereGeometry = new THREE.SphereGeometry(0.008, 16, 16);
            const rightSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            
            for (let i = 0; i < 21; i++) {
                const sphere = new THREE.Mesh(rightSphereGeometry, rightSphereMaterial);
                sphere.name = `right_landmark_${i}`;
                sphere.visible = false;
                scene.add(sphere);
                rightHandJoints[i] = sphere;
            }
            
            // ì™¼ì† ì—°ê²°ì„  ìƒì„±
            const leftLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                linewidth: 3,
                transparent: true,
                opacity: 0.9
            });
            
            LANDMARK_CONNECTIONS.forEach(([start, end]) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const line = new THREE.Line(geometry, leftLineMaterial);
                line.name = `left_connection_${start}_${end}`;
                line.visible = false;
                scene.add(line);
                leftHandConnections.push({ line, start, end });
            });
            
            // ì˜¤ë¥¸ì† ì—°ê²°ì„  ìƒì„±
            const rightLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff0000,
                linewidth: 3,
                transparent: true,
                opacity: 0.9
            });
            
            LANDMARK_CONNECTIONS.forEach(([start, end]) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const line = new THREE.Line(geometry, rightLineMaterial);
                line.name = `right_connection_${start}_${end}`;
                line.visible = false;
                scene.add(line);
                rightHandConnections.push({ line, start, end });
            });
        }
        
        // GLB ëª¨ë¸ ìë™ ë¡œë“œ
        async function loadModels() {
            const loader = new THREE.GLTFLoader();
            
            try {
                // ì™¼ì† ëª¨ë¸ ë¡œë“œ
                const leftGltf = await new Promise((resolve, reject) => {
                    loader.load(LEFT_HAND_MODEL, resolve, undefined, reject);
                });
                
                leftHandModel = leftGltf.scene;
                setupHandModel(leftHandModel, 'left');
                
                // ì˜¤ë¥¸ì† ëª¨ë¸ ë¡œë“œ
                const rightGltf = await new Promise((resolve, reject) => {
                    loader.load(RIGHT_HAND_MODEL, resolve, undefined, reject);
                });
                
                rightHandModel = rightGltf.scene;
                setupHandModel(rightHandModel, 'right');
                
                modelsLoaded = true;
                document.getElementById('modelStatus').textContent = 'ì–‘ì† ëª¨ë¸ ë¡œë“œ ì™„ë£Œ';
                document.getElementById('loading').style.display = 'none';
                console.log('GLB ëª¨ë¸ ë¡œë“œ ì™„ë£Œ');
                
            } catch (error) {
                console.error('GLB ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error);
                document.getElementById('modelStatus').textContent = 'ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨: ' + error.message;
                document.getElementById('loading').textContent = 'ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨';
                modelsLoaded = false;
            }
        }
        
        // í–¥ìƒëœ bone êµ¬ì¡° ë¶„ì„ ë° ë§¤í•‘ ê²€ì¦
        function setupHandModel(model, handType) {
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.material.side = THREE.DoubleSide;
                }
            });
            
            // bone êµ¬ì¡° ë¶„ì„ ë° ë§¤í•‘ ê²€ì¦
            console.log(`=== ${handType.toUpperCase()} HAND MODEL BONE ANALYSIS ===`);
            const bones = [];
            const mappedBones = [];
            const unmappedBones = [];
            
            model.traverse((child) => {
                if (child.isBone) {
                    bones.push(child.name);
                    const landmarkIndex = getBoneToLandmarkMapping(child.name);
                    
                    if (landmarkIndex >= 0) {
                        mappedBones.push({
                            bone: child.name,
                            landmark: landmarkIndex,
                            landmarkName: MEDIAPIPE_LANDMARK_NAMES[landmarkIndex]
                        });
                        console.log(`âœ“ MAPPED: "${child.name}" -> Landmark ${landmarkIndex} (${MEDIAPIPE_LANDMARK_NAMES[landmarkIndex]})`);
                    } else {
                        unmappedBones.push(child.name);
                        console.log(`âœ— UNMAPPED: "${child.name}"`);
                    }
                }
            });
            
            console.log(`\nğŸ“Š SUMMARY for ${handType} hand:`);
            console.log(`Total bones: ${bones.length}`);
            console.log(`Mapped bones: ${mappedBones.length}`);
            console.log(`Unmapped bones: ${unmappedBones.length}`);
            
            // UIì— ë§¤í•‘ ìƒíƒœ í‘œì‹œ
            const mappingPercentage = bones.length > 0 ? (mappedBones.length / bones.length * 100).toFixed(1) : 0;
            document.getElementById('boneMapping').textContent = 
                `${mappedBones.length}/${bones.length} (${mappingPercentage}%)`;
            
            if (unmappedBones.length > 0) {
                console.log('\nğŸ” UNMAPPED BONES:', unmappedBones);
                console.log('ğŸ’¡ Consider adding these to BONE_TO_LANDMARK_MAPPING for complete coverage');
            } else {
                console.log('\nğŸ‰ All bones successfully mapped!');
            }
            
            // ë§¤í•‘ëœ boneë“¤ì˜ ìƒì„¸ ì •ë³´
            console.log('\nğŸ“‹ MAPPED BONES DETAILS:');
            mappedBones.forEach(item => {
                console.log(`  "${item.bone}" -> ${item.landmark} (${item.landmarkName})`);
            });
            
            console.log('=======================================\n');
            
            // ëª¨ë¸ì„ ìœ„í•œ ì»¨í…Œì´ë„ˆ ìƒì„±
            const container = new THREE.Group();
            container.add(model);
            container.visible = false;
            scene.add(container);
            
            // ì»¨í…Œì´ë„ˆë¡œ êµì²´
            if (handType === 'left') {
                leftHandModel = container;
            } else {
                rightHandModel = container;
            }
        }
        
        // MediaPipe ì´ˆê¸°í™”
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onHandsResults);
        
        // ì›¹ìº  ì„¤ì •
        const video = document.getElementById('video');
        const camera_utils = new Camera(video, {
            onFrame: async () => {
                await hands.send({ image: video });
            },
            width: 640,
            height: 480
        });
        
        // FPS ê³„ì‚°
        let lastTime = performance.now();
        let frameCount = 0;
        
        // ì† ì¶”ì  ê²°ê³¼ ì²˜ë¦¬
        function onHandsResults(results) {
            const currentTime = performance.now();
            frameCount++;
            
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // ëª¨ë“  ëª¨ë¸ ìˆ¨ê¸°ê¸°
            if (leftHandModel) leftHandModel.visible = false;
            if (rightHandModel) rightHandModel.visible = false;
            
            // ëª¨ë“  ëœë“œë§ˆí¬ ìˆ¨ê¸°ê¸°
            Object.values(leftHandJoints).forEach(joint => joint.visible = false);
            Object.values(rightHandJoints).forEach(joint => joint.visible = false);
            leftHandConnections.forEach(({ line }) => line.visible = false);
            rightHandConnections.forEach(({ line }) => line.visible = false);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('handDetected').textContent = `${results.multiHandLandmarks.length}ê°œ ê°ì§€ë¨`;
                document.getElementById('status').textContent = 'ì† ì¶”ì  ì¤‘...';
                
                // ê° ì†ì— ëŒ€í•´ ì²˜ë¦¬
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    if (index < results.multiHandedness.length) {
                        const handedness = results.multiHandedness[index];
                        
                        // ì²« ë²ˆì§¸ ì†ì˜ ë°©í–¥ í‘œì‹œ
                        if (index === 0) {
                            document.getElementById('handedness').textContent = 
                                handedness.label === 'Left' ? 'ì™¼ì†' : 'ì˜¤ë¥¸ì†';
                        }
                        
                        // ì† ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                        updateHandPosition(landmarks, handedness.label, index);
                    }
                });
            } else {
                document.getElementById('handDetected').textContent = 'ê°ì§€ ì•ˆë¨';
                document.getElementById('handedness').textContent = '-';
            }
        }
        
        // 3D ì† ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        function updateHandPosition(landmarks, handedness, handIndex) {
            const positions = [];
            
            // ëœë“œë§ˆí¬ ìœ„ì¹˜ ê³„ì‚°
            for (let i = 0; i < landmarks.length; i++) {
                const landmark = landmarks[i];
                
                // MediaPipe ì¢Œí‘œë¥¼ Three.js ì¢Œí‘œë¡œ ë³€í™˜
                // ê±°ìš¸ íš¨ê³¼ë¥¼ ì œê±°í•˜ê¸° ìœ„í•´ xì¶•ì„ ë°˜ì „
                const x = -(landmark.x - 0.5) * 1.0;  // xì¶• ë°˜ì „
                const y = -(landmark.y - 0.5) * 1.0;
                const z = -landmark.z * 0.3;
                
                positions.push(new THREE.Vector3(x, y, z));
                
                // ëœë“œë§ˆí¬ ì‹œê°í™” ì—…ë°ì´íŠ¸ (ê° ì†ë³„ë¡œ ë¶„ë¦¬)
                if (showLandmarks) {
                    const isLeftHand = (handedness === 'Left');
                    const joints = isLeftHand ? leftHandJoints : rightHandJoints;
                    
                    if (joints[i]) {
                        joints[i].position.set(x, y, z);
                        joints[i].visible = true;
                    }
                }
                
                // ì†ëª© ìœ„ì¹˜ ë””ë²„ê¹…
                if (i === 0 && handIndex === 0) {
                    document.getElementById('wristPos').textContent = 
                        `x: ${x.toFixed(3)}, y: ${y.toFixed(3)}, z: ${z.toFixed(3)}`;
                }
            }
            
            // ì—°ê²°ì„  ì—…ë°ì´íŠ¸ (ê° ì†ë³„ë¡œ ë¶„ë¦¬)
            if (showLandmarks) {
                updateConnections(positions, handedness);
            }
            
            // GLB ëª¨ë¸ ì—…ë°ì´íŠ¸
            if (modelsLoaded) {
                // ì˜¬ë°”ë¥¸ ëª¨ë¸ ë§¤í•‘: ì™¼ì†ì€ ì™¼ì† ëª¨ë¸, ì˜¤ë¥¸ì†ì€ ì˜¤ë¥¸ì† ëª¨ë¸
                const model = handedness === 'Left' ? rightHandModel : leftHandModel;
                if (model) {
                    model.visible = true;
                    updateGLBModel(model, positions, landmarks, handedness);
                }
            }
        }
        
        // ì—°ê²°ì„  ì—…ë°ì´íŠ¸
        function updateConnections(positions, handedness) {
            const isLeftHand = (handedness === 'Left');
            const connections = isLeftHand ? leftHandConnections : rightHandConnections;
            
            connections.forEach(({ line, start, end }) => {
                if (positions[start] && positions[end]) {
                    const geometry = line.geometry;
                    const positionAttribute = geometry.attributes.position;
                    
                    positionAttribute.array[0] = positions[start].x;
                    positionAttribute.array[1] = positions[start].y;
                    positionAttribute.array[2] = positions[start].z;
                    positionAttribute.array[3] = positions[end].x;
                    positionAttribute.array[4] = positions[end].y;
                    positionAttribute.array[5] = positions[end].z;
                    
                    positionAttribute.needsUpdate = true;
                    line.visible = true;
                }
            });
        }
        
        // GLB ëª¨ë¸ ì—…ë°ì´íŠ¸ (ì •ë°€í•œ ëœë“œë§ˆí¬ ë§¤í•‘)
        function updateGLBModel(modelContainer, positions, landmarks, handedness) {
            if (!modelContainer || !modelContainer.children[0]) return;
            
            const model = modelContainer.children[0];
            
            // ì†ëª© ìœ„ì¹˜ë¡œ ëª¨ë¸ ì´ë™
            modelContainer.position.copy(positions[0]);
            
            // ì†ì— ë”°ë¥¸ íšŒì „ê°’ê³¼ ìŠ¤ì¼€ì¼ ì„ íƒ
            const isLeftHand = (handedness === 'Left');
            const rotationX = isLeftHand ? rightHandRotationX : leftHandRotationX;
            const rotationY = isLeftHand ? rightHandRotationY : leftHandRotationY;
            const rotationZ = isLeftHand ? rightHandRotationZ : leftHandRotationZ;
            const scaleFactor = isLeftHand ? rightHandScaleFactor : leftHandScaleFactor;
            
            // ì† í¬ê¸°ì— ë”°ë¥¸ ìŠ¤ì¼€ì¼ ì¡°ì •
            const handScale = positions[0].distanceTo(positions[9]) * scaleFactor;
            model.scale.set(handScale, handScale, handScale);
            
            // ì •ë°€í•œ ì†ë°”ë‹¥ ì¢Œí‘œê³„ êµ¬ì„±
            const wrist = positions[0];
            const indexMCP = positions[5];
            const middleMCP = positions[9];
            const pinkyMCP = positions[17];
            
            // ë” ì •í™•í•œ ì†ë°”ë‹¥ ë°©í–¥ ê³„ì‚°
            // 1. ì†ê°€ë½ë“¤ì˜ ê¸°ì €ë¶€ë¥¼ ì—°ê²°í•˜ëŠ” ë²¡í„°ë“¤
            const indexToMiddle = new THREE.Vector3().subVectors(middleMCP, indexMCP).normalize();
            const middleToPinky = new THREE.Vector3().subVectors(pinkyMCP, middleMCP).normalize();
            const indexToPinky = new THREE.Vector3().subVectors(pinkyMCP, indexMCP).normalize();
            
            // 2. ì†ëª©ì—ì„œ ì†ê°€ë½ ê¸°ì €ë¶€ ì¤‘ì‹¬ìœ¼ë¡œì˜ ë°©í–¥
            const fingerCenter = new THREE.Vector3()
                .addVectors(indexMCP, middleMCP)
                .add(pinkyMCP)
                .divideScalar(3);
            const wristToFingers = new THREE.Vector3().subVectors(fingerCenter, wrist).normalize();
            
            // 3. ì†ë°”ë‹¥ í‰ë©´ì˜ ë²•ì„  ë²¡í„° (ë” ì •í™•í•œ ê³„ì‚°)
            const palmNormal = new THREE.Vector3().crossVectors(indexToPinky, wristToFingers).normalize();
            
            // 4. ì†ë°”ë‹¥ì˜ ì¢Œìš° ë°©í–¥ (ì—„ì§€ìª½ì´ ì–‘ì˜ ë°©í–¥)
            const thumbDirection = new THREE.Vector3().subVectors(positions[2], wrist).normalize();
            const sideDirection = new THREE.Vector3().crossVectors(wristToFingers, palmNormal).normalize();
            
            // ì—„ì§€ ë°©í–¥ê³¼ ì¼ì¹˜í•˜ë„ë¡ ì¡°ì •
            if (thumbDirection.dot(sideDirection) < 0) {
                sideDirection.negate();
                palmNormal.negate();
            }
            
            // 5. ì •í™•í•œ íšŒì „ í–‰ë ¬ êµ¬ì„±
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.set(
                sideDirection.x, wristToFingers.x, palmNormal.x, 0,
                sideDirection.y, wristToFingers.y, palmNormal.y, 0,
                sideDirection.z, wristToFingers.z, palmNormal.z, 0,
                0, 0, 0, 1
            );
            
            // íšŒì „ í–‰ë ¬ì„ quaternionìœ¼ë¡œ ë³€í™˜í•˜ê³  ì ìš©
            const baseQuaternion = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
            
            // MediaPipeì™€ ëª¨ë¸ì˜ ì¢Œí‘œê³„ ì°¨ì´ ë³´ì •
            const correctionRotation = new THREE.Euler(
                Math.PI, // Xì¶• 180ë„ íšŒì „
                0,       // Yì¶•
                0,       // Zì¶•
                'XYZ'
            );
            const correctionQuaternion = new THREE.Quaternion().setFromEuler(correctionRotation);
            baseQuaternion.multiply(correctionQuaternion);
            
            modelContainer.quaternion.copy(baseQuaternion);
            
            // ì‚¬ìš©ì ì •ì˜ ì¶”ê°€ íšŒì „ ì ìš©
            const additionalRotation = new THREE.Euler(
                THREE.Math.degToRad(rotationX),
                THREE.Math.degToRad(rotationY),
                THREE.Math.degToRad(rotationZ),
                'XYZ'
            );
            const additionalQuaternion = new THREE.Quaternion().setFromEuler(additionalRotation);
            modelContainer.quaternion.multiply(additionalQuaternion);
            
            // ì •ë°€í•œ bone-to-landmark ë§¤í•‘ ì ìš©
            applyBoneToLandmarkMapping(model, positions, handedness);
            
            // ë§¤í•‘ í’ˆì§ˆ ê³„ì‚° ë° í‘œì‹œ
            updateMappingQuality(model, positions);
        }
        
        // ë§¤í•‘ í’ˆì§ˆ í‰ê°€ í•¨ìˆ˜
        function updateMappingQuality(model, positions) {
            let totalMappedBones = 0;
            let accurateMappings = 0;
            
            model.traverse((bone) => {
                if (bone.isBone) {
                    const landmarkIndex = getBoneToLandmarkMapping(bone.name);
                    if (landmarkIndex >= 0 && landmarkIndex < positions.length) {
                        totalMappedBones++;
                        
                        // ê°„ë‹¨í•œ ì •í™•ë„ ì²´í¬ (boneì´ ì ì ˆí•œ ëœë“œë§ˆí¬ ê·¼ì²˜ì— ìˆëŠ”ì§€)
                        const targetPosition = positions[landmarkIndex];
                        const boneWorldPosition = new THREE.Vector3();
                        bone.getWorldPosition(boneWorldPosition);
                        
                        // ì›”ë“œ ì¢Œí‘œê³„ì—ì„œì˜ ê±°ë¦¬ ì²´í¬
                        const distance = boneWorldPosition.distanceTo(targetPosition);
                        if (distance < 0.1) { // ì„ê³„ê°’ ë‚´ì— ìˆìœ¼ë©´ ì •í™•í•œ ë§¤í•‘ìœ¼ë¡œ ê°„ì£¼
                            accurateMappings++;
                        }
                    }
                }
            });
            
            const qualityPercentage = totalMappedBones > 0 ? (accurateMappings / totalMappedBones * 100).toFixed(1) : 0;
            document.getElementById('mappingQuality').textContent = `${qualityPercentage}% (${accurateMappings}/${totalMappedBones})`;
        }
        
        // ì™„ì „í•œ bone-to-landmark ë§¤í•‘ í•¨ìˆ˜ (í–¥ìƒëœ ìœ„ì¹˜/íšŒì „ ë§¤í•‘)
        function applyBoneToLandmarkMapping(model, positions, handedness) {
            if (!model || !positions || positions.length < 21) {
                return;
            }
            
            // ê° boneì„ ìˆœíšŒí•˜ë©° í•´ë‹¹í•˜ëŠ” ëœë“œë§ˆí¬ì— ì •í™•íˆ ë§¤í•‘
            model.traverse((bone) => {
                if (bone.isBone) {
                    const landmarkIndex = getBoneToLandmarkMapping(bone.name);
                    
                    if (landmarkIndex >= 0 && landmarkIndex < positions.length) {
                        const boneName = bone.name.toLowerCase();
                        
                        // bone íƒ€ì…ì— ë”°ë¥¸ ì •í™•í•œ ìœ„ì¹˜/íšŒì „ ë§¤í•‘
                        if (boneName.includes('wrist') || boneName.includes('hand') || boneName.includes('palm') || boneName.includes('root')) {
                            // ì†ëª©/ì†ë°”ë‹¥ - ê¸°ì¤€ì ì´ë¯€ë¡œ íŠ¹ë³„ ì²˜ë¦¬
                            applyWristBoneMapping(bone, positions, landmarkIndex);
                        } else {
                            // ëª¨ë“  ì†ê°€ë½ ê´€ì ˆì— ëŒ€í•´ ì •í™•í•œ ìœ„ì¹˜ì™€ íšŒì „ ì ìš©
                            applyPreciseBoneMapping(bone, positions, landmarkIndex, handedness);
                        }
                    }
                }
            });
        }
        
        // ì •ë°€í•œ bone ìœ„ì¹˜/íšŒì „ ë§¤í•‘
        function applyPreciseBoneMapping(bone, positions, landmarkIndex, handedness) {
            const targetPosition = positions[landmarkIndex];
            const boneName = bone.name.toLowerCase();
            
            // ì›ë˜ ìƒíƒœ ì €ì¥
            if (!bone.userData.originalPosition) {
                bone.userData.originalPosition = bone.position.clone();
                bone.userData.originalRotation = bone.rotation.clone();
            }
            
            // ì†ê°€ë½ ê´€ì ˆë³„ ì •í™•í•œ ë§¤í•‘
            if (boneName.includes('thumb')) {
                applyThumbPreciseMapping(bone, positions, landmarkIndex, handedness);
            } else if (boneName.includes('index')) {
                applyFingerPreciseMapping(bone, positions, landmarkIndex, 'index');
            } else if (boneName.includes('middle')) {
                applyFingerPreciseMapping(bone, positions, landmarkIndex, 'middle');
            } else if (boneName.includes('ring')) {
                applyFingerPreciseMapping(bone, positions, landmarkIndex, 'ring');
            } else if (boneName.includes('pinky') || boneName.includes('little')) {
                applyFingerPreciseMapping(bone, positions, landmarkIndex, 'pinky');
            }
        }
        
        // ì—„ì§€ì†ê°€ë½ ì •ë°€ ë§¤í•‘
        function applyThumbPreciseMapping(bone, positions, landmarkIndex, handedness) {
            const isLeftHand = (handedness === 'Left');
            
            // ì—„ì§€ ê´€ì ˆ ìˆœì„œ: CMC(1) -> MCP(2) -> IP(3) -> TIP(4)
            const thumbLandmarks = [1, 2, 3, 4];
            const currentIndex = thumbLandmarks.indexOf(landmarkIndex);
            
            if (currentIndex >= 0) {
                // í˜„ì¬ ê´€ì ˆê³¼ ë‹¤ìŒ ê´€ì ˆ ê°„ì˜ ë°©í–¥ ë²¡í„° ê³„ì‚°
                let targetDirection;
                if (currentIndex < thumbLandmarks.length - 1) {
                    // ë‹¤ìŒ ê´€ì ˆë¡œì˜ ë°©í–¥
                    const nextLandmark = thumbLandmarks[currentIndex + 1];
                    targetDirection = new THREE.Vector3()
                        .subVectors(positions[nextLandmark], positions[landmarkIndex])
                        .normalize();
                } else {
                    // ë§ˆì§€ë§‰ ê´€ì ˆì¸ ê²½ìš° ì´ì „ ê´€ì ˆì—ì„œì˜ ë°©í–¥ ì—°ì¥
                    const prevLandmark = thumbLandmarks[currentIndex - 1];
                    targetDirection = new THREE.Vector3()
                        .subVectors(positions[landmarkIndex], positions[prevLandmark])
                        .normalize();
                }
                
                // boneì˜ ì›ë˜ forward ë°©í–¥ (ì¼ë°˜ì ìœ¼ë¡œ Yì¶•)
                const originalForward = new THREE.Vector3(0, 1, 0);
                
                // íšŒì „ ê³„ì‚°
                const quaternion = new THREE.Quaternion().setFromUnitVectors(originalForward, targetDirection);
                bone.setRotationFromQuaternion(quaternion);
                
                // ì‚¬ìš©ì ì •ì˜ ì—„ì§€ íšŒì „ ì¶”ê°€
                const baseXRotation = isLeftHand ? (rightThumbRotationX * Math.PI / 180) : (leftThumbRotationX * Math.PI / 180);
                const baseYRotation = isLeftHand ? (rightThumbRotationY * Math.PI / 180) : (leftThumbRotationY * Math.PI / 180);
                const baseZRotation = isLeftHand ? (rightThumbRotationZ * Math.PI / 180) : (leftThumbRotationZ * Math.PI / 180);
                
                bone.rotation.x += baseXRotation;
                bone.rotation.y += baseYRotation;
                bone.rotation.z += baseZRotation;
            }
        }
        
        // ì¼ë°˜ ì†ê°€ë½ ì •ë°€ ë§¤í•‘
        function applyFingerPreciseMapping(bone, positions, landmarkIndex, fingerType) {
            // ì†ê°€ë½ë³„ ëœë“œë§ˆí¬ ìˆœì„œ
            const fingerRanges = {
                'index': [5, 6, 7, 8],    // MCP -> PIP -> DIP -> TIP
                'middle': [9, 10, 11, 12],
                'ring': [13, 14, 15, 16],
                'pinky': [17, 18, 19, 20]
            };
            
            const fingerLandmarks = fingerRanges[fingerType];
            if (!fingerLandmarks) return;
            
            const currentIndex = fingerLandmarks.indexOf(landmarkIndex);
            if (currentIndex >= 0) {
                // í˜„ì¬ ê´€ì ˆê³¼ ë‹¤ìŒ ê´€ì ˆ ê°„ì˜ ë°©í–¥ ë²¡í„° ê³„ì‚°
                let targetDirection;
                if (currentIndex < fingerLandmarks.length - 1) {
                    // ë‹¤ìŒ ê´€ì ˆë¡œì˜ ë°©í–¥
                    const nextLandmark = fingerLandmarks[currentIndex + 1];
                    targetDirection = new THREE.Vector3()
                        .subVectors(positions[nextLandmark], positions[landmarkIndex])
                        .normalize();
                } else {
                    // ë§ˆì§€ë§‰ ê´€ì ˆì¸ ê²½ìš° ì´ì „ ê´€ì ˆì—ì„œì˜ ë°©í–¥ ì—°ì¥
                    const prevLandmark = fingerLandmarks[currentIndex - 1];
                    targetDirection = new THREE.Vector3()
                        .subVectors(positions[landmarkIndex], positions[prevLandmark])
                        .normalize();
                }
                
                // boneì˜ ì›ë˜ forward ë°©í–¥
                const originalForward = new THREE.Vector3(0, 1, 0);
                
                // íšŒì „ ê³„ì‚° ë° ì ìš©
                const quaternion = new THREE.Quaternion().setFromUnitVectors(originalForward, targetDirection);
                bone.setRotationFromQuaternion(quaternion);
                
                // ì†ê°€ë½ êµ½í˜ì— ë”°ë¥¸ ì¶”ê°€ íšŒì „
                const bendAmount = calculateFingerBend(positions, fingerLandmarks);
                const maxBendAngle = Math.PI / 6; // 30ë„ë¡œ ì œí•œí•˜ì—¬ ìì—°ìŠ¤ëŸ¬ìš´ ì›€ì§ì„
                const bendRotation = bendAmount * maxBendAngle;
                
                // êµ½í˜ì„ boneì˜ ë¡œì»¬ Xì¶•ì— ì ìš© (ê´€ì ˆì˜ ìì—°ìŠ¤ëŸ¬ìš´ êµ½í˜ ë°©í–¥)
                bone.rotation.x += bendRotation;
            }
        }
        
        // ì†ëª©/ì†ë°”ë‹¥ ì •ë°€ ë§¤í•‘
        function applyWristBoneMapping(bone, positions, landmarkIndex) {
            // ì†ëª© boneì€ ì „ì²´ ì†ì˜ ê¸°ì¤€ì ì´ë¯€ë¡œ íŠ¹ë³„í•œ íšŒì „ ì—†ì´ ê¸°ë³¸ ìƒíƒœ ìœ ì§€
            // ëŒ€ì‹  ì†ë°”ë‹¥ í‰ë©´ì˜ ë°©í–¥ì„±ì„ ë°˜ì˜
            if (!bone.userData.originalRotation) {
                bone.userData.originalRotation = bone.rotation.clone();
            }
            
            // ì†ë°”ë‹¥ ë°©í–¥ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ê¸°ë³¸ íšŒì „ë§Œ ì ìš©
            const wrist = positions[0];
            const indexMCP = positions[5];
            const middleMCP = positions[9];
            const pinkyMCP = positions[17];
            
            // ì†ë°”ë‹¥ í‰ë©´ ê³„ì‚°
            const palmVector1 = new THREE.Vector3().subVectors(indexMCP, wrist);
            const palmVector2 = new THREE.Vector3().subVectors(pinkyMCP, wrist);
            const palmNormal = new THREE.Vector3().crossVectors(palmVector1, palmVector2).normalize();
            
            // ë¯¸ì„¸í•œ ì†ëª© íšŒì „ë§Œ ì ìš© (ë„ˆë¬´ í¬ì§€ ì•Šê²Œ)
            const originalUp = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(originalUp, palmNormal);
            quaternion.slerp(new THREE.Quaternion(), 0.7); // 70% ë§Œ ì ìš©í•˜ì—¬ ë¶€ë“œëŸ½ê²Œ
            
            bone.rotation.copy(bone.userData.originalRotation);
            bone.applyQuaternion(quaternion);
        }
        
        // ì†ê°€ë½ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateFingerAnimations(model, positions, handedness) {
            if (!model || !positions || positions.length < 21) {
                return;
            }
            
            // MediaPipe ëœë“œë§ˆí¬ì™€ ì¼ë°˜ì ì¸ ì†ê°€ë½ bone ì´ë¦„ ë§¤í•‘
            const fingerBoneMapping = {
                // ì—„ì§€ì†ê°€ë½ (1-4ë²ˆ ëœë“œë§ˆí¬)
                thumb: {
                    landmarks: [1, 2, 3, 4],
                    boneNames: ['thumb', 'Thumb']
                },
                // ê²€ì§€ì†ê°€ë½ (5-8ë²ˆ ëœë“œë§ˆí¬)
                index: {
                    landmarks: [5, 6, 7, 8],
                    boneNames: ['index', 'Index', 'finger_index', 'Finger_Index']
                },
                // ì¤‘ì§€ì†ê°€ë½ (9-12ë²ˆ ëœë“œë§ˆí¬)
                middle: {
                    landmarks: [9, 10, 11, 12],
                    boneNames: ['middle', 'Middle', 'finger_middle', 'Finger_Middle']
                },
                // ì•½ì§€ì†ê°€ë½ (13-16ë²ˆ ëœë“œë§ˆí¬)
                ring: {
                    landmarks: [13, 14, 15, 16],
                    boneNames: ['ring', 'Ring', 'finger_ring', 'Finger_Ring']
                },
                // ìƒˆë¼ì†ê°€ë½ (17-20ë²ˆ ëœë“œë§ˆí¬)
                pinky: {
                    landmarks: [17, 18, 19, 20],
                    boneNames: ['pinky', 'Pinky', 'little', 'Little', 'finger_pinky', 'Finger_Pinky']
                }
            };
            
            // ê° ì†ê°€ë½ì— ëŒ€í•´ êµ½í˜ ì •ë„ ê³„ì‚° ë° ì ìš©
            Object.entries(fingerBoneMapping).forEach(([fingerName, fingerData]) => {
                const { landmarks, boneNames } = fingerData;
                
                let bendAmount;
                
                // ì—„ì§€ì†ê°€ë½ì€ íŠ¹ë³„í•œ ê³„ì‚° ë°©ì‹ ì‚¬ìš©
                if (fingerName === 'thumb') {
                    bendAmount = calculateThumbBend(positions, handedness);
                } else {
                    // ì¼ë°˜ ì†ê°€ë½ì€ ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
                    bendAmount = calculateFingerBend(positions, landmarks);
                }
                
                // í•´ë‹¹ ì†ê°€ë½ì˜ boneë“¤ì„ ì°¾ì•„ì„œ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
                model.traverse((bone) => {
                    if (bone.isBone) {
                        const boneName = bone.name.toLowerCase();
                        const isMatchingBone = boneNames.some(name => 
                            boneName.includes(name.toLowerCase()) || 
                            name.toLowerCase().includes(boneName)
                        );
                        
                        if (isMatchingBone) {
                            // ì†ê°€ë½ êµ½í˜ íšŒì „ ì ìš©
                            applyFingerBend(bone, bendAmount, fingerName);
                        }
                    }
                });
            });
        }
        
        // ì†ê°€ë½ êµ½í˜ ì •ë„ ê³„ì‚°
        function calculateFingerBend(positions, landmarks) {
            if (landmarks.length < 4) return 0;
            
            const base = positions[landmarks[0]]; // MCP ê´€ì ˆ
            const middle = positions[landmarks[1]]; // PIP ê´€ì ˆ
            const upper = positions[landmarks[2]]; // DIP ê´€ì ˆ
            const tip = positions[landmarks[3]]; // ì†ê°€ë½ ë
            
            // ì „ì²´ ì†ê°€ë½ ê¸¸ì´ (í¼ì³¤ì„ ë•Œì˜ ê¸¸ì´)
            const totalLength = base.distanceTo(middle) + middle.distanceTo(upper) + upper.distanceTo(tip);
            
            // ì‹¤ì œ ëì ê¹Œì§€ì˜ ì§ì„  ê±°ë¦¬
            const directDistance = base.distanceTo(tip);
            
            // êµ½í˜ ë¹„ìœ¨ ê³„ì‚° (0: ì™„ì „íˆ í¼ì¹¨, 1: ì™„ì „íˆ êµ½í˜)
            const bendRatio = Math.max(0, Math.min(1, (totalLength - directDistance) / (totalLength * 0.3)));
            
            return bendRatio;
        }
        
        // ì—„ì§€ì†ê°€ë½ ì „ìš© êµ½í˜ ê³„ì‚° (ì†ë°”ë‹¥ ì•ˆìª½ìœ¼ë¡œ ì ‘í˜)
        function calculateThumbBend(positions, handedness) {
            // ì—„ì§€ ëœë“œë§ˆí¬: 1(CMC), 2(MCP), 3(IP), 4(tip)
            // ì†ëª©ê³¼ ê²€ì§€ MCPë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì—„ì§€ ì ‘í˜ ì •ë„ ê³„ì‚°
            const wrist = positions[0];
            const thumbTip = positions[4];
            const indexMCP = positions[5];
            const middleMCP = positions[9];
            
            // ì†ë°”ë‹¥ ì¤‘ì‹¬ì  ê³„ì‚°
            const palmCenter = new THREE.Vector3()
                .addVectors(indexMCP, middleMCP)
                .multiplyScalar(0.5);
            
            // ì—„ì§€ê°€ ì†ë°”ë‹¥ ì¤‘ì‹¬ì— ì–¼ë§ˆë‚˜ ê°€ê¹Œìš´ì§€ ê³„ì‚°
            const distanceTopalm = thumbTip.distanceTo(palmCenter);
            const maxDistance = wrist.distanceTo(indexMCP); // ìµœëŒ€ ê±°ë¦¬ ê¸°ì¤€
            
            // ì ‘í˜ ë¹„ìœ¨ ê³„ì‚° (0: í¼ì¹¨, 1: ì™„ì „íˆ ì ‘í˜)
            const foldRatio = Math.max(0, Math.min(1, 1 - (distanceTopalm / maxDistance)));
            
            // ì¶”ê°€ì ìœ¼ë¡œ ì—„ì§€ê°€ ì†ë°”ë‹¥ í‰ë©´ ì•„ë˜ë¡œ ë“¤ì–´ê°”ëŠ”ì§€ í™•ì¸
            const palmNormal = new THREE.Vector3()
                .subVectors(indexMCP, wrist)
                .cross(new THREE.Vector3().subVectors(middleMCP, wrist))
                .normalize();
            
            const thumbVector = new THREE.Vector3().subVectors(thumbTip, wrist);
            const dotProduct = thumbVector.dot(palmNormal);
            
            // ì†ë°”ë‹¥ ì•„ë˜ìª½ìœ¼ë¡œ ì ‘íŒ ì •ë„ë¥¼ ì¶”ê°€ ê³ ë ¤
            const belowPalmFactor = Math.max(0, -dotProduct * 2);
            
            return Math.min(1, foldRatio + belowPalmFactor);
        }
        
        // ì†ê°€ë½ì— êµ½í˜ íšŒì „ ì ìš©
        function applyFingerBend(bone, bendAmount, fingerName) {
            // ì›ë˜ íšŒì „ê°’ ì €ì¥ (ì²« ë²ˆì§¸ ì‹¤í–‰ ì‹œ)
            if (!bone.userData.originalRotation) {
                bone.userData.originalRotation = bone.rotation.clone();
            }
            
            // ê¸°ë³¸ íšŒì „ì—ì„œ ì‹œì‘
            const baseRotation = bone.userData.originalRotation;
            bone.rotation.copy(baseRotation);
            
            // ì—„ì§€ì†ê°€ë½ì€ íŠ¹ë³„í•œ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
            if (fingerName === 'thumb') {
                // ì—„ì§€ëŠ” ì†ë°”ë‹¥ ì•ˆìª½ìœ¼ë¡œ ì ‘íˆëŠ” ë™ì‘
                const maxBendAngle = Math.PI / 3; // 60ë„
                const bendRotation = bendAmount * maxBendAngle;
                
                // ì†ë³„ ì‚¬ìš©ì ì„¤ì • íšŒì „ê°’ ì‚¬ìš© (ì˜¬ë°”ë¥¸ ë§¤í•‘)
                const isLeftHand = (handedness === 'Left');
                const baseXRotation = isLeftHand ? (rightThumbRotationX * Math.PI / 180) : (leftThumbRotationX * Math.PI / 180);
                const baseYRotation = isLeftHand ? (rightThumbRotationY * Math.PI / 180) : (leftThumbRotationY * Math.PI / 180);
                const baseZRotation = isLeftHand ? (rightThumbRotationZ * Math.PI / 180) : (leftThumbRotationZ * Math.PI / 180);
                
                // ì—„ì§€ì˜ íšŒì „ì¶• ì„¤ì • (ì‚¬ìš©ì ì„¤ì •ê°’ + êµ½í˜ ë™ì‘)
                bone.rotation.x = baseXRotation + (bendRotation * 0.8); // Xì¶•: ê¸°ë³¸ íšŒì „ + êµ½í˜
                bone.rotation.y = baseYRotation + (bendRotation * 0.6); // Yì¶•: ê¸°ë³¸ íšŒì „ + êµ½í˜
                bone.rotation.z = baseZRotation + (bendRotation * 1.2); // Zì¶•: ê¸°ë³¸ íšŒì „ + êµ½í˜
                
                return;
            }
            
            // ì¼ë°˜ ì†ê°€ë½ êµ½í˜ ì²˜ë¦¬
            let maxBendAngle = Math.PI / 3; // ê¸°ë³¸ 60ë„
            
            switch (fingerName) {
                case 'index':
                case 'middle':
                    maxBendAngle = Math.PI / 2.5; // ê²€ì§€, ì¤‘ì§€ëŠ” 72ë„
                    break;
                case 'ring':
                case 'pinky':
                    maxBendAngle = Math.PI / 3; // ì•½ì§€, ìƒˆë¼ëŠ” 60ë„
                    break;
            }
            
            // êµ½í˜ íšŒì „ ì ìš© (ì£¼ë¡œ Xì¶• íšŒì „)
            const bendRotation = bendAmount * maxBendAngle;
            bone.rotation.x += bendRotation;
            
            // Yì¶•ê³¼ Zì¶•ì—ë„ ì•½ê°„ì˜ ìì—°ìŠ¤ëŸ¬ìš´ ì›€ì§ì„ ì¶”ê°€
            bone.rotation.y += bendAmount * 0.1;
            bone.rotation.z += bendAmount * 0.05;
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('showLandmarks').addEventListener('change', (e) => {
            showLandmarks = e.target.checked;
            saveSettings(); // ìë™ ì €ì¥
        });
        
        // ì €ì¥/ë¦¬ì…‹ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.getElementById('saveSettings').addEventListener('click', () => {
            saveSettings();
            alert('ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
        });
        
        document.getElementById('resetSettings').addEventListener('click', () => {
            if (confirm('ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë˜ëŒë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                // ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
                leftHandRotationX = 0;
                leftHandRotationY = 0;
                leftHandRotationZ = 0;
                leftHandScaleFactor = 11;
                rightHandRotationX = 0;
                rightHandRotationY = 0;
                rightHandRotationZ = 0;
                rightHandScaleFactor = 11;
                leftThumbRotationX = 0;
                leftThumbRotationY = 0;
                leftThumbRotationZ = 0;
                rightThumbRotationX = 0;
                rightThumbRotationY = 0;
                rightThumbRotationZ = 0;
                showLandmarks = true;
                
                updateSliderValues();
                saveSettings();
                alert('ì„¤ì •ì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤!');
            }
        });
        
        // ì™¼ì† íšŒì „ ì»¨íŠ¸ë¡¤
        document.getElementById('leftRotationX').addEventListener('input', (e) => {
            leftHandRotationX = parseFloat(e.target.value);
            document.getElementById('leftRotationXValue').textContent = leftHandRotationX + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('leftRotationY').addEventListener('input', (e) => {
            leftHandRotationY = parseFloat(e.target.value);
            document.getElementById('leftRotationYValue').textContent = leftHandRotationY + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('leftRotationZ').addEventListener('input', (e) => {
            leftHandRotationZ = parseFloat(e.target.value);
            document.getElementById('leftRotationZValue').textContent = leftHandRotationZ + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('leftModelScale').addEventListener('input', (e) => {
            leftHandScaleFactor = parseFloat(e.target.value);
            document.getElementById('leftModelScaleValue').textContent = leftHandScaleFactor.toFixed(1);
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('leftThumbRotationX').addEventListener('input', (e) => {
            leftThumbRotationX = parseFloat(e.target.value);
            document.getElementById('leftThumbRotationXValue').textContent = leftThumbRotationX + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('leftThumbRotationY').addEventListener('input', (e) => {
            leftThumbRotationY = parseFloat(e.target.value);
            document.getElementById('leftThumbRotationYValue').textContent = leftThumbRotationY + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('leftThumbRotationZ').addEventListener('input', (e) => {
            leftThumbRotationZ = parseFloat(e.target.value);
            document.getElementById('leftThumbRotationZValue').textContent = leftThumbRotationZ + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        // ì˜¤ë¥¸ì† íšŒì „ ì»¨íŠ¸ë¡¤
        document.getElementById('rightRotationX').addEventListener('input', (e) => {
            rightHandRotationX = parseFloat(e.target.value);
            document.getElementById('rightRotationXValue').textContent = rightHandRotationX + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('rightRotationY').addEventListener('input', (e) => {
            rightHandRotationY = parseFloat(e.target.value);
            document.getElementById('rightRotationYValue').textContent = rightHandRotationY + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('rightRotationZ').addEventListener('input', (e) => {
            rightHandRotationZ = parseFloat(e.target.value);
            document.getElementById('rightRotationZValue').textContent = rightHandRotationZ + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('rightModelScale').addEventListener('input', (e) => {
            rightHandScaleFactor = parseFloat(e.target.value);
            document.getElementById('rightModelScaleValue').textContent = rightHandScaleFactor.toFixed(1);
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('rightThumbRotationX').addEventListener('input', (e) => {
            rightThumbRotationX = parseFloat(e.target.value);
            document.getElementById('rightThumbRotationXValue').textContent = rightThumbRotationX + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('rightThumbRotationY').addEventListener('input', (e) => {
            rightThumbRotationY = parseFloat(e.target.value);
            document.getElementById('rightThumbRotationYValue').textContent = rightThumbRotationY + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        document.getElementById('rightThumbRotationZ').addEventListener('input', (e) => {
            rightThumbRotationZ = parseFloat(e.target.value);
            document.getElementById('rightThumbRotationZValue').textContent = rightThumbRotationZ + 'Â°';
            saveSettings(); // ìë™ ì €ì¥
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ì´ˆê¸°í™”
        loadSettings(); // ì €ì¥ëœ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
        initThreeJS();
        camera_utils.start();
        document.getElementById('status').textContent = 'ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ';
    </script>
</body>
</html>
